
        const SUPABASE_URL = 'https://hzyybvrzottzapelpxed.supabase.co';
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Imh6eXlidnJ6b3R0emFwZWxweGVkIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjA1MDI5NDQsImV4cCI6MjA3NjA3ODk0NH0.cqKDFgRpSAnfkoby3nleLnK2AnrZ1gO59ayX14a6Si0';
        
        window.products = [
            { id: 'PROD001', name: 'Café Americano', category: 'Bebidas', price: 2.5, stock: 10, ideal_stock: 20, unit: 'Taza', is_service: true, sold_by_weight: false, sold_by_length: false, allow_manual_price: false, image: '', description: 'Café negro, fuerte y aromático.' },
            { id: 'PROD002', name: 'Croissant', category: 'Panadería', price: 1.8, stock: 50, ideal_stock: 30, unit: 'Unidad', is_service: false, sold_by_weight: false, sold_by_length: false, allow_manual_price: false, image: '', description: 'Clásico hojaldre francés.' },
            { id: 'PROD003', name: 'Jugo de Naranja', category: 'Bebidas', price: 3.0, stock: 80, ideal_stock: 25, unit: 'Vaso', is_service: true, sold_by_weight: false, sold_by_length: false, allow_manual_price: false, image: '', description: 'Jugo 100% natural.' },
            { id: 'PROD004', name: 'Queso por Kilo', category: 'Lácteos', price: 15.0, stock: 5, ideal_stock: 10, unit: 'kg', is_service: false, sold_by_weight: true, sold_by_length: false, allow_manual_price: false, image: '', description: 'Queso blanco semiduro.' },
            { id: 'PROD005', name: 'Tela por Metro', category: 'Mercería', price: 8.5, stock: 100, ideal_stock: 50, unit: 'm', is_service: false, sold_by_weight: false, sold_by_length: true, allow_manual_price: false, image: '', description: 'Tela de algodón de alta calidad.' },
            { id: 'PROD006', name: 'Asesoría', category: 'Servicios', price: 50.0, stock: 999, ideal_stock: 999, unit: 'Hora', is_service: true, sold_by_weight: false, sold_by_length: false, allow_manual_price: true, image: '', description: 'Asesoría profesional por hora.' }
        ];

        const fullSqlScript = `
            -- Cleanup existing objects to avoid conflicts when re‑initialising the database.
            DROP FUNCTION IF EXISTS decrement_stock(text, numeric);
            DROP FUNCTION IF EXISTS is_admin_user(uuid) CASCADE;
            DROP FUNCTION IF EXISTS create_profile_for_new_user() CASCADE;
            DROP TABLE IF EXISTS credit_payments CASCADE;
            DROP TABLE IF EXISTS clientes CASCADE;
            DROP TABLE IF EXISTS venta_items;
            DROP TABLE IF EXISTS ventas CASCADE;
            DROP TABLE IF EXISTS productos CASCADE;
            DROP TABLE IF EXISTS profiles CASCADE;

            -- Ensure uuid functions are available
            CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

            -- Core tables
            CREATE TABLE productos (
                id TEXT PRIMARY KEY,
                name TEXT NOT NULL,
                description TEXT,
                category TEXT,
                price NUMERIC DEFAULT 0,
                stock NUMERIC DEFAULT 0,
                ideal_stock NUMERIC DEFAULT 0,
                unit TEXT DEFAULT 'Unidad',
                is_service BOOLEAN DEFAULT FALSE,
                sold_by_weight BOOLEAN DEFAULT FALSE,
                sold_by_length BOOLEAN DEFAULT FALSE,
                allow_manual_price BOOLEAN DEFAULT FALSE,
                image TEXT,
                created_at TIMESTAMPTZ DEFAULT NOW()
            );

            -- Table of customers who may take purchases on credit.  Each
            -- customer has a credit limit, an outstanding balance and a risk
            -- category.  The risk category can be used to group customers
            -- into tiers as recommended in credit‑management guidelines.
            CREATE TABLE clientes (
                id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
                nombre TEXT NOT NULL,
                telefono TEXT,
                email TEXT,
                direccion TEXT,
                limite_credito NUMERIC DEFAULT 0,
                saldo_pendiente NUMERIC DEFAULT 0,
                riesgo TEXT DEFAULT 'medio',
                created_at TIMESTAMPTZ DEFAULT NOW()
            );

            CREATE TABLE ventas (
                id TEXT PRIMARY KEY,
                created_at TIMESTAMPTZ DEFAULT NOW(),
                total_usd NUMERIC NOT NULL,
                exchange_rate NUMERIC,
                items INTEGER,
                payment_methods JSONB,
                -- Reference to the customer if the sale is on credit.
                cliente_id UUID REFERENCES clientes(id) ON DELETE SET NULL,
                -- Remaining balance for credit sales.  For cash sales this
                -- will always be zero.
                saldo_restante NUMERIC DEFAULT 0,
                seller_id UUID REFERENCES auth.users(id) ON DELETE SET NULL
            );

            CREATE TABLE venta_items (
                id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                venta_id TEXT REFERENCES ventas(id) ON DELETE CASCADE,
                producto_id TEXT REFERENCES productos(id) ON DELETE SET NULL,
                quantity NUMERIC NOT NULL,
                price NUMERIC NOT NULL
            );

            -- Table that stores payments made toward credit sales.  Each
            -- record reduces the saldo_restante of the corresponding sale.
            CREATE TABLE credit_payments (
                id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                venta_id TEXT REFERENCES ventas(id) ON DELETE CASCADE,
                cliente_id UUID REFERENCES clientes(id) ON DELETE CASCADE,
                monto_pagado NUMERIC NOT NULL,
                fecha_pago TIMESTAMPTZ DEFAULT NOW(),
                metodo TEXT
            );

            -- Profiles table stores the role for each authenticated user.  New
            -- users are given the "buyer" role by default and can be promoted
            -- to "seller" or "admin" by an administrator.
            CREATE TABLE profiles (
                id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
                role TEXT NOT NULL DEFAULT 'buyer'
            );

            -- Automatically insert a profile row when a new auth user is created.
            CREATE OR REPLACE FUNCTION public.create_profile_for_new_user()
            RETURNS TRIGGER AS $$
            BEGIN
                -- Insert the new user's profile with default role 'buyer'.  Use the
                -- fully‑qualified table name to avoid search_path issues.
                INSERT INTO public.profiles(id, role) VALUES (NEW.id, 'buyer');
                RETURN NEW;
            END;
            $$ LANGUAGE plpgsql SECURITY DEFINER;

            CREATE TRIGGER on_auth_user_created
            AFTER INSERT ON auth.users
            FOR EACH ROW EXECUTE FUNCTION public.create_profile_for_new_user();

            -- Helper function to test whether the supplied user id belongs to
            -- an administrator.  Used in row‑level security policies to
            -- restrict operations to admins.
            CREATE OR REPLACE FUNCTION is_admin_user(user_id UUID)
            RETURNS BOOLEAN
            LANGUAGE plpgsql
            SECURITY DEFINER
            AS $$
            DECLARE
                is_admin BOOLEAN;
            BEGIN
                SELECT role = 'admin' INTO is_admin FROM profiles WHERE id = user_id;
                RETURN COALESCE(is_admin, false);
            END;
            $$;

            -- Helper function to decrement stock for non‑service products when
            -- recording a sale.  This function is invoked from the client code
            -- after a successful sale.
            -- The decrement_stock function now runs with SECURITY DEFINER so
            -- that it can update the productos table on behalf of sellers.
            -- Without SECURITY DEFINER, row‑level security would prevent
            -- sellers from decrementing stock (only admins could update).
            CREATE OR REPLACE FUNCTION decrement_stock(product_id TEXT, decrement_value NUMERIC)
            RETURNS void
            LANGUAGE plpgsql
            SECURITY DEFINER AS $$
            BEGIN
                UPDATE productos
                SET stock = stock - decrement_value
                WHERE id = product_id AND is_service = FALSE;
            END;
            $$;

            -- Enable row level security (RLS) on all tables.  Without RLS
            -- policies, no authenticated user can access table rows.
            ALTER TABLE productos ENABLE ROW LEVEL SECURITY;
            ALTER TABLE ventas    ENABLE ROW LEVEL SECURITY;
            ALTER TABLE venta_items ENABLE ROW LEVEL SECURITY;
            ALTER TABLE profiles ENABLE ROW LEVEL SECURITY;
            ALTER TABLE clientes ENABLE ROW LEVEL SECURITY;
            ALTER TABLE credit_payments ENABLE ROW LEVEL SECURITY;

            -- Products: everyone can read; only administrators can insert,
            -- update or delete products.  Sellers and buyers may never
            -- modify the catalogue.
            CREATE POLICY "Productos public read" ON productos
              FOR SELECT USING (true);
            CREATE POLICY "Productos admin manage" ON productos
              FOR ALL USING (is_admin_user(auth.uid()))
              WITH CHECK (is_admin_user(auth.uid()));

            -- Profiles: each user can view their own profile row.  Only
            -- administrators can edit or view other users' profiles.
            CREATE POLICY "Profiles: user can view own" ON profiles
              FOR SELECT TO authenticated
              USING (id = auth.uid());
            CREATE POLICY "Profiles: admin manage" ON profiles
              FOR ALL TO authenticated
              USING (is_admin_user(auth.uid()))
              WITH CHECK (is_admin_user(auth.uid()));

            -- Allow the trigger function to insert a profile row when a new
            -- user registers.  Without this explicit insert policy, row
            -- level security would prevent the insert from happening.
            CREATE POLICY "Profiles: allow insert" ON profiles
              FOR INSERT
              WITH CHECK (true);

            -- Sales (ventas): sellers and administrators can insert and read
            -- sales; only administrators can update or delete existing sales.
            CREATE POLICY "Ventas: sellers insert" ON ventas
              FOR INSERT TO authenticated
              WITH CHECK (EXISTS (SELECT 1 FROM profiles WHERE id = auth.uid() AND role IN ('seller','admin')));
            CREATE POLICY "Ventas: sellers view" ON ventas
              FOR SELECT TO authenticated
              USING (EXISTS (SELECT 1 FROM profiles WHERE id = auth.uid() AND role IN ('seller','admin')));
            CREATE POLICY "Ventas: admin manage" ON ventas
              FOR ALL TO authenticated
              USING (is_admin_user(auth.uid()))
              WITH CHECK (is_admin_user(auth.uid()));

            -- Sale items: sellers and administrators can insert, view and
            -- update sale items; only administrators can delete them.
            CREATE POLICY "Venta items: sellers insert" ON venta_items
              FOR INSERT TO authenticated
              WITH CHECK (EXISTS (SELECT 1 FROM profiles WHERE id = auth.uid() AND role IN ('seller','admin')));
            CREATE POLICY "Venta items: sellers view" ON venta_items
              FOR SELECT TO authenticated
              USING (EXISTS (SELECT 1 FROM profiles WHERE id = auth.uid() AND role IN ('seller','admin')));
            CREATE POLICY "Venta items: sellers update" ON venta_items
              FOR UPDATE TO authenticated
              USING (EXISTS (SELECT 1 FROM profiles WHERE id = auth.uid() AND role IN ('seller','admin')))
              WITH CHECK (EXISTS (SELECT 1 FROM profiles WHERE id = auth.uid() AND role IN ('seller','admin')));
            CREATE POLICY "Venta items: admin delete" ON venta_items
              FOR DELETE TO authenticated
              USING (is_admin_user(auth.uid()));

            -- Customers: sellers and administrators can insert new customers
            -- and view existing ones.  Only administrators can update or
            -- delete customer records.
            CREATE POLICY "Clientes: sellers insert" ON clientes
              FOR INSERT TO authenticated
              WITH CHECK (EXISTS (SELECT 1 FROM profiles WHERE id = auth.uid() AND role IN ('seller','admin')));
            CREATE POLICY "Clientes: sellers view" ON clientes
              FOR SELECT TO authenticated
              USING (EXISTS (SELECT 1 FROM profiles WHERE id = auth.uid() AND role IN ('seller','admin')));
            CREATE POLICY "Clientes: admin manage" ON clientes
              FOR ALL TO authenticated
              USING (is_admin_user(auth.uid()))
              WITH CHECK (is_admin_user(auth.uid()));

            -- Credit payments: sellers and administrators can insert
            -- (record payments) and view payment records; only
            -- administrators can update or delete them.
            CREATE POLICY "Credit payments: sellers insert" ON credit_payments
              FOR INSERT TO authenticated
              WITH CHECK (EXISTS (SELECT 1 FROM profiles WHERE id = auth.uid() AND role IN ('seller','admin')));
            CREATE POLICY "Credit payments: sellers view" ON credit_payments
              FOR SELECT TO authenticated
              USING (EXISTS (SELECT 1 FROM profiles WHERE id = auth.uid() AND role IN ('seller','admin')));
            CREATE POLICY "Credit payments: admin manage" ON credit_payments
              FOR ALL TO authenticated
              USING (is_admin_user(auth.uid()))
              WITH CHECK (is_admin_user(auth.uid()));

            -- Include productos table in the realtime publication so that
            -- product changes are broadcast to clients via websockets.
            ALTER PUBLICATION supabase_realtime ADD TABLE productos;
        `;
        
        const { createClient } = supabase;
        window.supabaseClient = null;
        let allProducts = [], session = null, currentModal = null;
        let appLoaded = false;
        window.cart = [];
        let deferredInstallPrompt = null;
        let isBcvAuto = true;
        let latestBcvRate = 0;

        // Role of currently signed in user.  Possible values: 'admin', 'seller', 'buyer'.
        let userRole = null;
        // List of clients loaded from the database.  Used to populate
        // client selectors and compute credit balances.
        let clients = [];

        /**
         * Fetch the role of the current user from the `profiles` table.
         * On error or if not authenticated, userRole will be null.
         */
        async function fetchUserRole() {
            if (!session || !supabaseClient) {
                userRole = null;
                return;
            }
            try {
                const { data, error } = await supabaseClient
                    .from('profiles')
                    .select('role')
                    .eq('id', session.user.id)
                    .single();
                if (error) {
                    console.error('Error fetching user role:', error);
                    userRole = null;
                } else {
                    userRole = data?.role || null;
                    // Persist the user's role and id for offline use
                    if (userRole) {
                        try {
                            localStorage.setItem('userRole', userRole);
                            if (session && session.user && session.user.id) {
                                localStorage.setItem('userId', session.user.id);
                            }
                        } catch(err) {
                            console.warn('Could not persist user role', err);
                        }
                    }
                }
            } catch (err) {
                console.error('Error fetching user role:', err);
                userRole = null;
            }
        }

        /**
         * Update UI controls that depend on the user's role.
         * Admins can see and use management and analysis buttons.
         */
        function updateUIByRole() {
            // Determine role flags.  Administrators inherit seller permissions.
            const isAdmin  = userRole === 'admin';
            const isSeller = userRole === 'seller' || isAdmin;
            // Consider unauthenticated visitors as buyers so they can view the catalog
            const isBuyer  = !session || userRole === 'buyer';

            // Gestión del catálogo sólo para administradores
            const manageBtn = document.getElementById('btn-manage-products');
            if (manageBtn) {
                manageBtn.classList.toggle('hidden', !isAdmin);
                manageBtn.disabled = !session || !isAdmin;
            }

            // Botón para crear vendedores (sólo visible y habilitado para administradores)
            const createSellerBtn = document.getElementById('btn-create-seller');
            if (createSellerBtn) {
                createSellerBtn.classList.toggle('hidden', !isAdmin);
                createSellerBtn.disabled = !session || !isAdmin;
            }

            // Botón para gestionar vendedores (listar/editar/eliminar) solo para administradores
            const manageSellersBtn = document.getElementById('btn-manage-sellers');
            if (manageSellersBtn) {
                manageSellersBtn.classList.toggle('hidden', !isAdmin);
                manageSellersBtn.disabled = !session || !isAdmin;
            }

            // El botón de análisis de ventas se ha eliminado, por lo que no es necesario alternar su visibilidad

            // Opciones de venta (finalizar venta y WhatsApp) accesibles para vendedores y administradores.
            ['btn-finalize', 'btn-wa'].forEach(id => {
                const el = document.getElementById(id);
                if (el) {
                    el.classList.toggle('hidden', !isSeller || !session);
                    el.disabled = !session || !isSeller;
                }
            });
            // El resumen del día sólo lo ve el administrador
            const summaryBtn = document.getElementById('btn-summary');
            if (summaryBtn) {
                summaryBtn.classList.toggle('hidden', !isAdmin || !session);
                summaryBtn.disabled = !session || !isAdmin;
            }

            // El botón de gestionar ventas sólo para administradores
            const manageSalesBtn = document.getElementById('btn-manage-sales');
            if (manageSalesBtn) {
                manageSalesBtn.classList.toggle('hidden', !isAdmin || !session);
                manageSalesBtn.disabled = !session || !isAdmin;
            }
        }

        Object.defineProperty(window, 'exchangeRate', { get: () => parseFloat(document.getElementById('exchange_rate').value) || 0 });

        const DOM = {
            themeToggleBtn: document.getElementById('theme-toggle-btn'), productGrid: document.getElementById('product-grid'),
            viewToggleBtn: document.getElementById('view-toggle-btn'), modalContainer: document.getElementById('modal-container'),
            cartDrawer: document.getElementById('cart-drawer'), cartItemsContainer: document.getElementById('cart-items'),
            cartTotalUsdEl: document.getElementById('cart-total-usd'), cartTotalBsEl: document.getElementById('cart-total-bs'),
            cartItemCountEl: document.getElementById('cart-item-count'), searchInput: document.getElementById('search-input'),
            authButton: document.getElementById('auth-button'), authIcon: document.getElementById('auth-icon'),
            installAppBtn: document.getElementById('install-app-btn'),
            bcvToggleBtn: document.getElementById('bcv-toggle-btn'),
            exchangeRateInput: document.getElementById('exchange_rate'),
        };

        function showToast(message, duration = 3000) {
            const toast = document.getElementById('toast');
            toast.querySelector('#toast-message').textContent = message;
            toast.style.opacity = 1;
            setTimeout(() => { toast.style.opacity = 0; }, duration);
        }

        function formatCurrency(amount, currency = 'USD') {
            return new Intl.NumberFormat('en-US', { style: 'currency', currency: currency === 'USD' ? 'USD' : 'VES' }).format(amount).replace('VES', 'Bs');
        }
        
        function slugify(text) {
             if (typeof text !== 'string') return '';
             const a = 'àáâäæãåāăąçćčđďèéêëēėęěğǵḧîïíīįìłḿñńǹňôöòóœøōõőṕŕřßśšşșťțûüùúūǘůűųẃẍÿýžźż·/_,:;'
             const b = 'aaaaaaaaaacccddeeeeeeeegghiiiiiilmnnnnoooooooooprrsssssttuuuuuuuuuwxyyzzz------'
             const p = new RegExp(a.split('').join('|'), 'g')
             return text.toString().toLowerCase().replace(/\s+/g, '-').replace(p, c => b.charAt(a.indexOf(c))).replace(/&/g, '-and-').replace(/[^\w\-]+/g, '').replace(/\-\-+/g, '-').replace(/^-+/, '').replace(/-+$/, '')
        }

        function normalizeText(text = '') {
            return text.toString().toLowerCase().normalize("NFD").replace(/[\u0300-\u036f]/g, "");
        }

        const Theme = {
            sunIcon: '<i class="fas fa-sun text-gray-600 dark:text-gray-300"></i>',
            moonIcon: '<i class="fas fa-moon text-gray-600 dark:text-gray-300"></i>',
            apply(theme) {
                document.documentElement.classList.toggle('dark', theme === 'dark');
                DOM.themeToggleBtn.innerHTML = theme === 'dark' ? this.sunIcon : this.moonIcon;
            },
            toggle() {
                const newTheme = document.documentElement.classList.contains('dark') ? 'light' : 'dark';
                localStorage.setItem('theme', newTheme);
                this.apply(newTheme);
            }
        };

        function openModal(modalId) {
            const modalContent = document.getElementById(modalId);
            if (!modalContent) return;
            DOM.modalContainer.querySelectorAll('.modal-content').forEach(mc => mc.classList.add('hidden'));
            modalContent.classList.remove('hidden');
            DOM.modalContainer.className = 'modal-overlay-bg fixed inset-0 flex items-center justify-center z-30';
            currentModal = modalId;
        }

        function closeModal() {
            if (!currentModal) return;
            const modalContent = document.getElementById(currentModal);
            if (modalContent) modalContent.classList.add('hidden');
            DOM.modalContainer.classList.add('hidden');
            currentModal = null;
        }
        
        function showConfirmation(message) {
             return new Promise(resolve => {
                 const wrap = document.createElement('div');
                 wrap.className = 'modal-overlay-bg fixed inset-0 flex items-center justify-center z-50';
                 wrap.innerHTML = `<div class="bg-secondary p-6 rounded-lg shadow-xl w-full max-w-sm text-center">
                     <h3 class="text-xl font-bold mb-3">Confirmación</h3>
                     <p class="mb-6">${message}</p>
                     <div class="flex justify-center space-x-4">
                         <button id="confirm-cancel-btn" class="btn btn-secondary w-28">Cancelar</button>
                         <button id="confirm-ok-btn" class="btn btn-primary w-28">Aceptar</button>
                     </div>
                 </div>`;
                 document.body.appendChild(wrap);
                 const close = (value) => { wrap.remove(); resolve(value); };
                 wrap.querySelector('#confirm-ok-btn').onclick = () => close(true);
                 wrap.querySelector('#confirm-cancel-btn').onclick = () => close(false);
             });
        }

        function renderProducts(productsToRender = allProducts) {
            DOM.productGrid.innerHTML = '';
            document.getElementById('no-products-msg').classList.toggle('hidden', productsToRender.length > 0);
            productsToRender.forEach(p => {
                const card = document.createElement('div');
                card.className = 'product-card bg-secondary rounded-lg shadow-md p-3 flex flex-col cursor-pointer transition-all duration-200 hover:shadow-xl dark:border dark:border-border-color';
                card.dataset.productId = p.id;
                
                let stockInfo;
                if (p.is_service) {
                    stockInfo = '<span class="text-indigo-500">Servicio</span>';
                } else if (p.stock <= 0) {
                    stockInfo = '<span class="font-bold text-red-500">No disponible</span>';
                } else {
                    const stockColor = p.stock > 10 ? 'text-green-500' : 'text-yellow-500';
                    stockInfo = `<span class="${stockColor}">${p.stock} ${p.unit}</span>`;
                }

                const isLowStock = !p.is_service && p.stock > 0 && p.stock <= (p.ideal_stock || 0) && (p.ideal_stock || 0) > 0;
                
                const badgeHTML = p.stock <= 0 && !p.is_service ? '<div class="absolute top-1 right-1 bg-red-600 text-white text-xs font-bold px-2 py-1 rounded-full">No Disponible</div>'
                                  : isLowStock ? '<div class="absolute top-1 right-1 bg-yellow-500 text-white text-xs font-bold px-2 py-1 rounded-full">Poco Stock</div>' : '';

                const priceBs = (p.price * window.exchangeRate).toFixed(2);
                card.innerHTML = `
                    <div class="product-image-container relative flex-shrink-0">
                        <img src="${p.image || 'https://placehold.co/300x200/e2e8f0/adb5bd?text=P'}" alt="${p.name}" class="w-full h-24 md:h-32 object-cover rounded-md mb-2">
                        ${badgeHTML}
                    </div>
                    <div class="product-info-container flex flex-col flex-grow">
                        <div class="flex-grow">
                            <h4 class="font-bold text-sm">${p.name}</h4>
                            <p class="text-xs text-text-secondary">${p.category || ''}</p>
                        </div>
                        <div class="mt-2 text-xs">
                            <div class="flex justify-between items-center">
                                <span class="font-semibold text-base" style="color: var(--primary-color);">${formatCurrency(p.price)}</span>
                                ${stockInfo}
                            </div>
                            <div class="text-right text-text-secondary">Bs ${priceBs}</div>
                        </div>
                    </div>`;
                card.addEventListener('click', () => handleProductClick(p.id));
                DOM.productGrid.appendChild(card);
            });
        }
        
        function renderCategoryFilters() {
            const categories = ['Todos', ...new Set(allProducts.map(p => p.category).filter(Boolean))];
            const container = document.getElementById('category-filters');
            container.innerHTML = '';
            categories.forEach(category => {
                const btn = document.createElement('button');
                btn.className = 'category-btn flex-shrink-0';
                if (category === 'Todos') btn.classList.add('active');
                btn.textContent = category;
                btn.dataset.category = category;
                btn.addEventListener('click', handleFilterClick);
                container.appendChild(btn);
            });

            const lowStockBtn = document.createElement('button');
            lowStockBtn.className = 'category-btn flex-shrink-0 text-yellow-400 border-yellow-400 dark:text-yellow-400 dark:border-yellow-500';
            lowStockBtn.innerHTML = `<i class="fas fa-exclamation-triangle mr-1"></i>Bajo Stock`;
            lowStockBtn.dataset.filter = 'low-stock';
            lowStockBtn.addEventListener('click', handleFilterClick);
            container.appendChild(lowStockBtn);
        }
        
        function renderCart() {
            DOM.cartItemsContainer.innerHTML = ''; let totalUsd = 0;
            if (window.cart.length === 0) {
                DOM.cartItemsContainer.innerHTML = `<p class="text-center text-text-secondary mt-8">El carrito está vacío.</p>`;
            } else {
                window.cart.forEach(item => {
                    const subtotal = item.price * item.quantity; totalUsd += subtotal;
                    const itemEl = document.createElement('div');
                    itemEl.className = 'flex items-center justify-between py-3 border-b border-border-color';
                    itemEl.innerHTML = `
                        <div class="w-2/3 flex items-center">
                            <div>
                                <p class="font-semibold text-sm">${item.name}</p>
                                <p class="text-xs text-text-secondary">${formatCurrency(item.price)}</p>
                            </div>
                        </div>
                        <div class="w-1/3 flex flex-col items-end">
                            <p class="font-bold mb-1">${formatCurrency(subtotal)}</p>
                            <div class="flex items-center gap-2">
                                <button data-id="${item.id}" data-price="${item.price}" class="decrease-qty-btn btn btn-secondary p-0 w-6 h-6">-</button>
                                <span class="font-semibold w-8 text-center">${item.quantity}</span>
                                <button data-id="${item.id}" data-price="${item.price}" class="increase-qty-btn btn btn-secondary p-0 w-6 h-6">+</button>
                                <button data-id="${item.id}" data-price="${item.price}" class="remove-item-btn text-red-500 hover:text-red-700 ml-2"><i class="fas fa-trash"></i></button>
                            </div>
                        </div>`;
                    DOM.cartItemsContainer.appendChild(itemEl);
                });
            }
            DOM.cartTotalUsdEl.textContent = formatCurrency(totalUsd); DOM.cartTotalBsEl.textContent = formatCurrency(totalUsd * window.exchangeRate, 'BS');
            DOM.cartItemCountEl.textContent = window.cart.length;

            const setupCartButtonListeners = (selector, change) => {
                DOM.cartItemsContainer.querySelectorAll(selector).forEach(btn => btn.addEventListener('click', e => {
                    const { id, price } = e.currentTarget.dataset;
                    updateCartQuantity(id, price, change);
                }));
            };
            
            setupCartButtonListeners('.increase-qty-btn', 1);
            setupCartButtonListeners('.decrease-qty-btn', -1);

            DOM.cartItemsContainer.querySelectorAll('.remove-item-btn').forEach(btn => btn.addEventListener('click', e => {
                const { id, price } = e.currentTarget.dataset;
                window.cart = window.cart.filter(item => !(item.id === id && item.price == price)); 
                renderCart();
            }));
        }

        function updateCartQuantity(productId, price, change) {
            const itemIndex = window.cart.findIndex(item => item.id === productId && item.price == price);
            if (itemIndex > -1) {
                const item = window.cart[itemIndex];
                const product = allProducts.find(p => p.id === productId);
                const newQuantity = item.quantity + change;

                if (change > 0 && !item.is_service && newQuantity > product.stock) {
                    showToast(`Stock máximo alcanzado para ${item.name}. Disponible: ${product.stock}`, 4000);
                    return;
                }

                if (newQuantity <= 0) {
                    window.cart.splice(itemIndex, 1);
                } else {
                    const isDecimal = item.sold_by_weight || item.sold_by_length;
                    item.quantity = isDecimal ? parseFloat(newQuantity.toFixed(2)) : newQuantity;
                }
                renderCart();
            }
        }

        function filterProducts() {
            const query = normalizeText(DOM.searchInput.value);
            const activeFilterBtn = document.querySelector('#category-filters .category-btn.active');
            
            let productsToRender = allProducts;

            if (activeFilterBtn) {
                const filterType = activeFilterBtn.dataset.filter;
                const category = activeFilterBtn.dataset.category;

                if (filterType === 'low-stock') {
                    productsToRender = allProducts.filter(p => !p.is_service && p.stock <= (p.ideal_stock || 0) && (p.ideal_stock || 0) > 0);
                } else if (category && category !== 'Todos') {
                    productsToRender = allProducts.filter(p => p.category === category);
                }
            }

            if (query) {
                productsToRender = productsToRender.filter(p => normalizeText(p.name).includes(query) || normalizeText(p.category).includes(query));
            }
            
            renderProducts(productsToRender);
        }

        function handleFilterClick(e) {
            document.querySelectorAll('#category-filters .category-btn').forEach(btn => btn.classList.remove('active'));
            e.currentTarget.classList.add('active');
            filterProducts();
        }

        function handleProductClick(productId) {
            const product = allProducts.find(p => p.id === productId);
            if (!product) return;

            if (!product.is_service && product.stock <= 0) {
                showToast(`${product.name} no está disponible.`, 3000);
                return;
            }

            const currentQtyInCart = window.cart.filter(item => item.id === productId).reduce((acc, item) => acc + item.quantity, 0);

            if (!product.is_service && currentQtyInCart >= product.stock) {
                showToast(`No hay más stock para ${product.name}.`, 4000);
                return;
            }

            if (product.sold_by_weight || product.sold_by_length || product.allow_manual_price) {
                openQuantityModal(product);
            } else {
                addToCart(product, 1, product.price);
            }
        }

        function addToCart(product, quantity, price) {
            const existingItem = window.cart.find(item => item.id === product.id && item.price === price);
            const currentQtyInCart = existingItem ? existingItem.quantity : 0;
            
            if (!product.is_service && (currentQtyInCart + quantity) > product.stock) {
                showToast(`Stock insuficiente para ${product.name}. Disponible: ${product.stock}`, 4000);
                return;
            }

            if (existingItem) {
                existingItem.quantity += quantity;
            } else {
                window.cart.push({ ...product, quantity, price });
            }
            showToast(`${product.name} agregado al carrito.`); renderCart();
        }

        async function fetchAndUpdateExchangeRate() {
            const lastUpdateEl = document.getElementById('rate-last-update');
            const bcvDisplayEl = document.getElementById('bcv-rate-display');
            try {
                const response = await fetch('https://ve.dolarapi.com/v1/dolares/oficial', { cache: 'no-cache' });
                if (!response.ok) throw new Error('Network response error');
                const data = await response.json();
                const bcvRate = data?.promedio || data?.venta;
                if (bcvRate) {
                    latestBcvRate = bcvRate;
                    bcvDisplayEl.textContent = `BCV: ${latestBcvRate.toFixed(2)}`;
                    bcvDisplayEl.classList.remove('hidden');
                    if (isBcvAuto) {
                        DOM.exchangeRateInput.value = latestBcvRate.toFixed(2);
                        lastUpdateEl.textContent = `Actualizado: ${new Date().toLocaleTimeString('es-VE')}`;
                    }
                    renderCart();
                    filterProducts();
                } else {
                    lastUpdateEl.textContent = 'No se pudo actualizar';
                }
            } catch (error) {
                console.error('Error fetching exchange rate:', error);
                lastUpdateEl.textContent = 'Error al actualizar';
                bcvDisplayEl.textContent = 'BCV: -';
                bcvDisplayEl.classList.remove('hidden');
            }
        }
        
        function clearCartAndNotify(message = 'Venta registrada con éxito.') { window.cart = []; renderCart(); showToast(message); }

        const paymentMethodsConfig = [ { id: 'efectivo_usd', label: 'Efectivo USD', icon: 'fa-money-bill-wave' }, { id: 'efectivo_bs', label: 'Efectivo Bs', icon: 'fa-money-bill-wave' }, { id: 'zelle', label: 'Zelle', icon: 'fa-bolt' }, { id: 'tarjeta', label: 'Tarjeta', icon: 'fa-credit-card' }, { id: 'pago_movil', label: 'Pago Móvil', icon: 'fa-mobile-alt' }, ];
        function openPaymentModal() {
            const totalUSD = window.cart.reduce((sum, item) => sum + (item.price * item.quantity), 0);
            document.getElementById('payment-total-display').textContent = formatCurrency(totalUSD);
            const container = document.getElementById('payment-methods-container');
            container.innerHTML = '';
            paymentMethodsConfig.forEach(method => {
                const el = document.createElement('div');
                el.className = 'flex items-center gap-3';
                el.innerHTML = `<label for="payment-${method.id}" class="w-1/3 flex items-center gap-2 text-sm text-text-primary"><i class="fas ${method.icon} text-text-secondary"></i> ${method.label}</label><input type="number" id="payment-${method.id}" data-method="${method.id}" class="payment-input modal-input flex-grow p-2" placeholder="0.00">`;
                container.appendChild(el);
            });
            container.querySelectorAll('.payment-input').forEach(input => input.addEventListener('input', updatePaymentBalance));
            updatePaymentBalance(); openModal('payment-modal');
        }

        function updatePaymentBalance() {
            const totalUSD = window.cart.reduce((sum, item) => sum + (item.price * item.quantity), 0);
            let paidAmount = 0; document.querySelectorAll('.payment-input').forEach(input => { paidAmount += parseFloat(input.value) || 0; });
            const remaining = totalUSD - paidAmount; const remainingEl = document.getElementById('payment-remaining'); const confirmBtn = document.getElementById('confirm-payment-btn');
            if (Math.abs(remaining) < 0.001) { remainingEl.className = 'text-xl font-bold text-green-500'; remainingEl.textContent = '¡Pagado!'; confirmBtn.disabled = false; }
            else if (remaining < 0) { remainingEl.className = 'text-xl font-bold text-yellow-500'; remainingEl.textContent = `Cambio: ${formatCurrency(Math.abs(remaining))}`; confirmBtn.disabled = false; }
            else { remainingEl.className = 'text-xl font-bold text-red-500'; remainingEl.textContent = `Restante: ${formatCurrency(remaining)}`; confirmBtn.disabled = true; }
        }

        function openQuantityModal(product) {
            document.getElementById('quantity-product-id').value = product.id;
            const titleEl = document.getElementById('quantity-modal-title');
            const labelEl = document.getElementById('quantity-label');
            const inputEl = document.getElementById('quantity-input');
            const priceContainer = document.getElementById('price-input-container');
            const priceInputEl = document.getElementById('manual-price-input');
            titleEl.textContent = product.name; inputEl.value = '1';
            if (product.sold_by_weight) { labelEl.textContent = 'Cantidad (kg)'; inputEl.step = '0.01'; }
            else if (product.sold_by_length) { labelEl.textContent = 'Longitud (m)'; inputEl.step = '0.01'; }
            else { labelEl.textContent = 'Cantidad'; inputEl.step = '1'; }
            priceContainer.classList.toggle('hidden', !product.allow_manual_price);
            if(product.allow_manual_price) priceInputEl.value = product.price;
            openModal('quantity-modal');
        }

        function renderProductManagementList() {
            const container = document.getElementById('product-list-container');
            container.innerHTML = '';
            if (allProducts.length === 0) {
                container.innerHTML = `<p class="text-text-secondary text-center p-4">No hay productos.</p>`;
                return;
            }
            // Filtra por el texto de búsqueda en el gestor
            const searchEl = document.getElementById('product-manage-search');
            const query = searchEl ? searchEl.value.trim().toLowerCase() : '';
            const filtered = allProducts.filter(p => p.name.toLowerCase().includes(query));
            filtered.sort((a,b) => a.name.localeCompare(b.name)).forEach(p => {
                const item = document.createElement('div');
                item.className = 'flex justify-between items-center p-2 border-b border-border-color last:border-b-0 hover:bg-accent';
                item.innerHTML = `<div><p class="font-semibold">${p.name}</p><p class="text-sm text-text-secondary">${formatCurrency(p.price)} - Stock: ${p.stock}</p></div><button data-id="${p.id}" class="edit-product-btn btn btn-secondary text-sm">Editar</button>`;
                container.appendChild(item);
            });
            document.querySelectorAll('.edit-product-btn').forEach(btn => btn.addEventListener('click', (e) => openProductForm(e.target.dataset.id)));
        }

        function renderCategoryManagementList() {
            const container = document.getElementById('category-list-container');
            container.innerHTML = '';
            const categories = [...new Set(allProducts.map(p => p.category).filter(Boolean))].sort();
            if (categories.length === 0) {
                 container.innerHTML = `<p class="text-text-secondary text-center p-4">No hay categorías.</p>`;
                 return;
            }
            container.innerHTML = categories.map(cat => `
                <div class="flex justify-between items-center p-2 border-b border-border-color last:border-b-0 hover:bg-accent">
                    <span>${cat}</span>
                    <button data-category="${cat}" class="delete-category-btn btn btn-danger text-xs py-1 px-2">Eliminar</button>
                </div>
            `).join('');
            document.querySelectorAll('.delete-category-btn').forEach(btn => btn.addEventListener('click', (e) => handleDeleteCategory(e.target.dataset.category)));
        }
        
        function switchManagementTab(tabToShow) {
            const productsTabBtn = document.getElementById('tab-btn-products');
            const categoriesTabBtn = document.getElementById('tab-btn-categories');
            const productsContent = document.getElementById('product-list-container');
            const categoriesContent = document.getElementById('category-list-container');
            
            const activeClasses = 'border-indigo-500 text-indigo-600 dark:border-indigo-400 dark:text-indigo-400'.split(' ');
            const inactiveClasses = 'border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300 dark:text-gray-400 dark:hover:text-gray-300 dark:hover:border-gray-600'.split(' ');

            if (tabToShow === 'products') {
                productsContent.classList.remove('hidden');
                categoriesContent.classList.add('hidden');
                
                productsTabBtn.classList.add(...activeClasses);
                productsTabBtn.classList.remove(...inactiveClasses);
                
                categoriesTabBtn.classList.add(...inactiveClasses);
                categoriesTabBtn.classList.remove(...activeClasses);

            } else { // 'categories'
                productsContent.classList.add('hidden');
                categoriesContent.classList.remove('hidden');
                
                categoriesTabBtn.classList.add(...activeClasses);
                categoriesTabBtn.classList.remove(...inactiveClasses);
                
                productsTabBtn.classList.add(...inactiveClasses);
                productsTabBtn.classList.remove(...activeClasses);
            }
        }

        async function handleDeleteCategory(category) {
            if (!await showConfirmation(`¿Seguro que quieres eliminar la categoría "${category}"? Esto eliminará TODOS los productos dentro de ella de forma permanente.`)) return;
            
            const productsToDelete = allProducts.filter(p => p.category === category);
            if (productsToDelete.length === 0) {
                showToast(`No se encontraron productos para eliminar en "${category}".`);
                return;
            }
            const productIdsToDelete = productsToDelete.map(p => p.id);

            const { error } = await supabaseClient.from('productos').delete().in('id', productIdsToDelete);
            
            if (error) {
                showToast('Error al eliminar: ' + error.message);
            } else {
                showToast(`Categoría "${category}" y sus productos eliminados.`);
            }

            // The real-time listener will handle the UI update.
            // For a snappier feel, we can also update locally, but the listener is the source of truth.
            allProducts = allProducts.filter(p => p.category !== category);
            localStorage.setItem('products', JSON.stringify(allProducts));
            renderCategoryManagementList();
            renderProductManagementList();
            filterProducts(); 
            renderCategoryFilters();
        }

        function openProductForm(productId = null) {
            const form = document.getElementById('product-form'); form.reset();
            const title = document.getElementById('product-form-title');
            const deleteBtn = document.getElementById('delete-product-btn');

            let datalist = document.getElementById('category-list');
            if (!datalist) {
                datalist = document.createElement('datalist');
                datalist.id = 'category-list';
                document.body.appendChild(datalist);
            }
            const categories = [...new Set(allProducts.map(p => p.category).filter(Boolean))];
            datalist.innerHTML = categories.map(cat => `<option value="${cat}"></option>`).join('');

            if (productId) {
                const p = allProducts.find(p => p.id === productId);
                title.textContent = 'Editar Producto'; deleteBtn.classList.remove('hidden');
                document.getElementById('product-id').value = p.id; document.getElementById('product-name').value = p.name;
                document.getElementById('product-category').value = p.category; document.getElementById('product-price').value = p.price;
                document.getElementById('product-stock').value = p.stock; document.getElementById('product-ideal_stock').value = p.ideal_stock || 0;
                document.getElementById('product-unit').value = p.unit; document.getElementById('product-image').value = p.image; document.getElementById('product-description').value = p.description || '';
                document.getElementById('product-is_service').checked = p.is_service; document.getElementById('product-sold_by_weight').checked = p.sold_by_weight;
                document.getElementById('product-sold_by_length').checked = p.sold_by_length; document.getElementById('product-allow_manual_price').checked = p.allow_manual_price;
            } else {
                title.textContent = 'Crear Producto'; deleteBtn.classList.add('hidden');
                document.getElementById('product-id').value = '';
            }
            openModal('product-form-modal');
        }
        
        function lockUIBySession() {
            const locked = !session;
            DOM.authIcon.classList.toggle('text-green-500', !!session);
            DOM.authIcon.innerHTML = session ? `<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17 16l4-4m0 0l-4-4m4 4H7m6 4v1a3 3 0 01-3 3H6a3 3 0 01-3-3V7a3 3 0 013-3h4a3 3 0 013 3v1" />` : `<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z" />`;
            document.getElementById('logout-button').classList.toggle('hidden', locked);
            ['btn-finalize', 'btn-wa', 'btn-summary', 'btn-manage-products'].forEach(id => {
                 const el = document.getElementById(id); if (el) el.disabled = locked;
            });
        }
        
        function buildTicket(cartData, rate) {
            let ticket = '--- TICKET DE VENTA ---\n\n'; let totalUSD = 0;
            cartData.forEach(item => {
                const subtotal = item.price * item.quantity; totalUSD += subtotal;
                ticket += `${item.name}\n  ${item.quantity} ${item.unit} x ${formatCurrency(item.price)} = ${formatCurrency(subtotal)}\n`;
            });
            ticket += '\n--------------------\n'; ticket += `TOTAL USD: ${formatCurrency(totalUSD)}\n`;
            ticket += `TOTAL Bs: ${formatCurrency(totalUSD * rate, 'BS')} (Tasa: ${rate})\n`;
            ticket += `\nFecha: ${new Date().toLocaleString('es-VE')}`;
            return ticket;
        }

        async function callGemini(prompt) {
            document.getElementById('gemini-modal-content').innerHTML = `<div class="flex items-center justify-center h-full"><div class="animate-spin rounded-full h-16 w-16 border-b-2 border-indigo-500"></div></div>`;
            openModal('gemini-modal');
            const apiKey = ""; const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;
            const payload = { contents: [{ parts: [{ text: prompt }] }] };
            try {
                const response = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                if (!response.ok) { const errorBody = await response.json(); throw new Error(`API Error: ${response.status} - ${errorBody.error.message}`); }
                const result = await response.json(); const candidate = result.candidates?.[0];
                if (candidate?.content?.parts?.[0]?.text) { return candidate.content.parts[0].text; }
                else { throw new Error("No se recibió contenido de la API de Gemini."); }
            } catch (error) {
                console.error("Error calling Gemini API:", error);
                document.getElementById('gemini-modal-content').innerHTML = `<p class="text-red-500">Ocurrió un error.</p><p class="text-xs mt-2">${error.message}</p>`;
                return null;
            }
        }
        
        async function analyzeDailySales() {
            if(!session) { showToast("Debes iniciar sesión para esta función."); return; }
            document.getElementById('gemini-modal-title').textContent = '✨ Análisis de Ventas del Día';
            document.getElementById('gemini-modal-footer').innerHTML = `<button type="button" class="btn-close-modal btn btn-secondary">Cerrar</button>`;
            try {
                const startOfDay = new Date(); startOfDay.setHours(0,0,0,0);
                const { data: sales, error: salesError } = await supabaseClient.from('ventas').select('id, total_usd').gte('created_at', startOfDay.toISOString());
                if (salesError) throw salesError;
                if (!sales || sales.length === 0) { showToast('No hay ventas hoy para analizar.'); return; }
                const saleIds = sales.map(s => s.id);
                const { data: items, error: itemsError } = await supabaseClient.from('venta_items').select('producto_id, quantity, price').in('venta_id', saleIds);
                if (itemsError) throw itemsError; if (!items || items.length === 0) { showToast('No se encontraron productos vendidos hoy.'); return; }

                const productSales = items.reduce((acc, item) => {
                    const productName = (allProducts.find(p => p.id === item.producto_id) || { name: 'Desconocido' }).name;
                    if (!acc[productName]) acc[productName] = { quantity: 0, revenue: 0 };
                    acc[productName].quantity += item.quantity; acc[productName].revenue += item.quantity * item.price;
                    return acc;
                }, {});
                let salesSummary = 'Productos vendidos hoy:\n';
                for (const name in productSales) { salesSummary += `- ${name}: ${productSales[name].quantity.toFixed(2)} unidades, $${productSales[name].revenue.toFixed(2)} en ingresos.\n`; }
                const totalRevenue = sales.reduce((sum, s) => sum + s.total_usd, 0);
                salesSummary += `\nIngresos totales del día: $${totalRevenue.toFixed(2)}.`;
                const prompt = `Eres un asesor de negocios. Analiza el siguiente resumen de ventas del día. Proporciona un análisis breve y 3 recomendaciones claras y accionables en formato de lista. El tono debe ser optimista y motivador.\n\nResumen de Ventas:\n${salesSummary}\n\nAnálisis y Recomendaciones:`;
                const analysis = await callGemini(prompt);
                if (analysis) {
                    const geminiModalContent = document.getElementById('gemini-modal-content');
                    geminiModalContent.innerHTML = analysis.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>').replace(/\*(.*?)\*/g, '<em>$1</em>').replace(/(\n\s*-\s)/g, '<br> &bull; ').replace(/\n/g, '<br>');
                }
            } catch (error) {
                console.error("Error analyzing sales:", error); showToast("Error al analizar las ventas: " + error.message); closeModal();
            }
        }

        const __offlineQueue = (function(){
            const KEY = 'offlineQueueV1';
            const load = () => { try { return JSON.parse(localStorage.getItem(KEY) || '[]'); } catch { return []; } };
            const save = q => localStorage.setItem(KEY, JSON.stringify(q));
            
            async function process(){
                if(!navigator.onLine || !window.supabaseClient) return;
                const { data:{ session } } = await supabaseClient.auth.getSession();
                if(!session) return;
                const q = load();
                if(!q.length) return;
                
                showToast('Sincronizando ventas offline...');
                const next = [];
                for(const job of q){
                    try {
                        if(job.type === 'venta'){
                            const { error:e1 } = await supabaseClient.from('ventas').insert([job.venta]); if(e1) throw e1;
                            if(job.items?.length){ const { error:e2 } = await supabaseClient.from('venta_items').insert(job.items); if(e2) throw e2; }
                            for(const upd of (job.stockUpdates||[])){
                                const { error:e3 } = await supabaseClient.rpc('decrement_stock', { product_id: upd.id, decrement_value: upd.quantityToDecrement });
                                if(e3) throw e3;
                            }
                        } else if(job.type === 'upsert_products' && job.rows?.length){
                            const { error:e4 } = await supabaseClient.from('productos').upsert(job.rows, { onConflict:'id' });
                            if(e4) throw e4;
                        }
                    } catch(err) {
                        console.error('Offline job failed, re-queuing:', err);
                        next.push(job);
                    }
                }
                save(next);
                if(next.length < q.length) showToast('Sincronización completada.');
            }
            
            function start() {
                window.addEventListener('online', process);
                if (window.supabaseClient) supabaseClient.auth.onAuthStateChange((event) => { if (event === 'SIGNED_IN') process(); });
                setInterval(process, 30000);
            }
            
            return { enqueue(job){ const q = load(); q.push(job); save(q); }, start };
        })();
        
        async function ensureProductsSynced(){
            if(!session) return;
            const { count, error } = await supabaseClient.from('productos').select('*', { head: true, count: 'exact' });
            if(error || (count || 0) > 0) return;

            showToast('Sincronizando catálogo inicial...');
            const payload = window.products.map(p=>({
                id: p.id, name: p.name, category: p.category, description: p.description, price: p.price, stock: p.stock,
                ideal_stock: p.ideal_stock, unit: p.unit, is_service: p.is_service, sold_by_weight: p.sold_by_weight, sold_by_length: p.sold_by_length,
                allow_manual_price: p.allow_manual_price, image: p.image
            }));
            
            const { error: upErr } = await supabaseClient.from('productos').upsert(payload, { onConflict: 'id' });
            if(upErr) {
                __offlineQueue.enqueue({ type:'upsert_products', rows: payload });
                showToast('Error de conexión. Se sincronizará el catálogo más tarde.');
            } else {
                showToast('Catálogo inicial sincronizado.');
                allProducts = payload; renderProducts(); renderCategoryFilters();
            }
        }
        
        async function recordSale(paymentMethods = {}){
            const ventaId = 'v_' + Date.now();
            const totalUSD = window.cart.reduce((s,it)=> s + (it.price * it.quantity), 0);
            const venta = { id: ventaId, total_usd: totalUSD, exchange_rate: window.exchangeRate, items: window.cart.length, payment_methods: paymentMethods, seller_id: session.user.id };
            const items = window.cart.map(it=>({ venta_id: ventaId, producto_id: it.id, quantity: it.quantity, price: it.price }));
            
            const { error:e1 } = await supabaseClient.from('ventas').insert([venta]);
            if(e1) throw e1;
            
            if(items.length){ const { error:e2 } = await supabaseClient.from('venta_items').insert(items); if(e2) throw e2; }
            
            for(const it of window.cart){ if(!it.is_service) await supabaseClient.rpc('decrement_stock', { product_id: it.id, decrement_value: it.quantity }); }
        }

        async function safeRecordSale(paymentMethods) {
            try {
                // Ensure we have a session or restore it from local storage for offline sales
                if (!session) {
                    const storedId = localStorage.getItem('userId');
                    if (storedId) {
                        session = { user: { id: storedId } };
                    } else {
                        throw new Error('Debes iniciar sesión para esta acción');
                    }
                }
                // Completar la venta en línea y salir
                await recordSale(paymentMethods);
                return true;
            } catch(e) {
                console.warn('Online sale recording failed, enqueuing offline.', e);
                try {
                    const sellerId = session && session.user ? session.user.id : localStorage.getItem('userId');
                    if (!sellerId) throw new Error('Sin identificador de usuario para venta offline');
                    const ventaId = 'v_off_' + Date.now();
                    const totalUSD = window.cart.reduce((s,it)=> s + (it.price*it.quantity), 0);
                    const venta = { id: ventaId, total_usd: totalUSD, exchange_rate: window.exchangeRate, items: window.cart.length, payment_methods: paymentMethods, seller_id: sellerId };
                    const items = window.cart.map(it=>({ venta_id: ventaId, producto_id: it.id, quantity: it.quantity, price: it.price }));
                    const stockUpdates = window.cart.filter(it=>!it.is_service).map(it=>({ id: it.id, quantityToDecrement: it.quantity }));
                    __offlineQueue.enqueue({ type:'venta', venta, items, stockUpdates });

                    // Instant stock update in local state
                    window.cart.forEach(cartItem => {
                        if (!cartItem.is_service) {
                            const productIndex = allProducts.findIndex(p => p.id === cartItem.id);
                            if (productIndex > -1) {
                                allProducts[productIndex].stock -= cartItem.quantity;
                            }
                        }
                    });
                    localStorage.setItem('products', JSON.stringify(allProducts));
                    filterProducts();

                    showToast('Venta guardada offline. Se sincronizará automáticamente.');
                    return true;
                } catch(e2) {
                    console.error('Failed to enqueue offline sale:', e2);
                    showToast('No se pudo registrar la venta ni guardarla offline.', 5000);
                    return false;
                }
            }
        }

        /**
         * Carga la lista de clientes desde la tabla "clientes" de Supabase y
         * actualiza la variable global `clients`.  Si ocurre un error al
         * obtener los datos, se mostrará una notificación al usuario.
         */
        async function fetchClients() {
            if (!supabaseClient) return;
            try {
                const { data, error } = await supabaseClient
                    .from('clientes')
                    .select('*')
                    .order('nombre', { ascending: true });
                if (error) {
                    console.error(error);
                    showToast('Error al cargar clientes: ' + error.message);
                    clients = [];
                    return;
                }
                clients = data || [];
            } catch (err) {
                console.error(err);
                showToast('No se pudieron obtener los clientes.');
            }
        }

        /**
         * Renderiza la lista de clientes dentro del modal de gestión de
         * clientes.  Cada cliente se muestra con su nombre, límite de
         * crédito, saldo pendiente y botones para editar y abonar.
         */
        function renderClientsList(list = clients) {
            const container = document.getElementById('client-list-container');
            if (!container) return;
            container.innerHTML = '';
            const source = list || [];
            if (!source || source.length === 0) {
                container.innerHTML = '<p class="text-text-secondary text-center p-4">No hay clientes.</p>';
                return;
            }
            source.forEach(c => {
                const saldoBs = (c.saldo_pendiente || 0) * window.exchangeRate;
                const row = document.createElement('div');
                row.className = 'flex justify-between items-center p-2 border-b border-border-color last:border-b-0 hover:bg-accent';
                // Se añaden botones de ver detalles, editar y abonar.  El botón de
                // detalles permite revisar todas las ventas a crédito y sus
                // operaciones para este cliente.
                row.innerHTML = `
                    <div>
                        <p class="font-semibold">${c.nombre}</p>
                        <p class="text-sm text-text-secondary">Límite: ${formatCurrency(c.limite_credito)} - Saldo: ${formatCurrency(c.saldo_pendiente)} / ${formatCurrency(saldoBs, 'BS')}</p>
                    </div>
                    <div class="flex gap-2">
                        <button data-id="${c.id}" class="view-client-btn btn btn-secondary text-xs">Ver</button>
                        <button data-id="${c.id}" class="edit-client-btn btn btn-secondary text-xs">Editar</button>
                        <button data-id="${c.id}" class="pay-client-btn btn btn-primary text-xs">Abonar</button>
                    </div>
                `;
                container.appendChild(row);
            });
            // Añade listeners para ver, editar y abonar después de renderizar
            container.querySelectorAll('.view-client-btn').forEach(btn => btn.addEventListener('click', e => {
                const id = e.currentTarget.dataset.id;
                openClientDetails(id);
            }));
            container.querySelectorAll('.edit-client-btn').forEach(btn => btn.addEventListener('click', e => {
                const id = e.currentTarget.dataset.id;
                openClientForm(id);
            }));
            container.querySelectorAll('.pay-client-btn').forEach(btn => btn.addEventListener('click', e => {
                const id = e.currentTarget.dataset.id;
                openClientPayment(id);
            }));
        }

        /**
         * Abre el modal de gestión de clientes, cargando primero la lista de
         * clientes desde Supabase y luego renderizando la lista en pantalla.
         */
        async function openClientsModal() {
            await fetchClients();
            renderClientsList();
            // Configura el filtro de búsqueda de clientes
            const searchInput = document.getElementById('client-search');
            if (searchInput) {
                searchInput.value = '';
                // Asigna el manejador directamente para evitar duplicar eventos en cada apertura
                searchInput.oninput = () => {
                    const term = searchInput.value.toLowerCase();
                    const filtered = clients.filter(c =>
                        (c.nombre || '').toLowerCase().includes(term) ||
                        (c.telefono || '').toLowerCase().includes(term) ||
                        (c.email || '').toLowerCase().includes(term)
                    );
                    renderClientsList(filtered);
                };
            }
            openModal('clients-modal');
        }

        /**
         * Abre el formulario para crear o editar un cliente.  Si se
         * proporciona un id, los campos se llenan con los datos del
         * cliente existente.  En caso contrario, se abre un formulario
         * limpio para un nuevo cliente.
         */
        function openClientForm(clientId = null) {
            const idInput = document.getElementById('client-id');
            const nameInput = document.getElementById('client-name');
            const phoneInput = document.getElementById('client-phone');
            const emailInput = document.getElementById('client-email');
            const addressInput = document.getElementById('client-address');
            const limitInput = document.getElementById('client-limit');
            const titleEl = document.getElementById('client-form-title');
            idInput.value = clientId || '';
            if (clientId) {
                const c = clients.find(x => x.id === clientId);
                titleEl.textContent = 'Editar Cliente';
                if (c) {
                    nameInput.value = c.nombre || '';
                    phoneInput.value = c.telefono || '';
                    emailInput.value = c.email || '';
                    addressInput.value = c.direccion || '';
                    limitInput.value = c.limite_credito || 0;
                }
            } else {
                titleEl.textContent = 'Nuevo Cliente';
                nameInput.value = '';
                phoneInput.value = '';
                emailInput.value = '';
                addressInput.value = '';
                limitInput.value = 0;
            }
            openModal('client-form-modal');
        }

        /**
         * Maneja el flujo de pago de crédito para un cliente.  Actualmente
         * muestra un prompt simple para ingresar el monto a abonar y
         * registra el pago en la tabla credit_payments mientras actualiza
         * el saldo restante en la venta y en el cliente.  Este flujo
         * simplificado no permite seleccionar una venta específica; abona
         * sobre el saldo total pendiente del cliente.
         */
        async function openClientPayment(clientId) {
            const client = clients.find(c => c.id === clientId);
            if (!client) return;
            const montoStr = prompt(`Ingrese el monto a abonar para ${client.nombre}. Saldo actual: ${formatCurrency(client.saldo_pendiente)}`);
            const monto = parseFloat(montoStr);
            if (isNaN(monto) || monto <= 0) {
                showToast('Monto inválido.');
                return;
            }
            try {
                // Buscar la venta más antigua con saldo pendiente para este cliente
                const { data: ventasPendientes, error: ve } = await supabaseClient
                    .from('ventas')
                    .select('*')
                    .eq('cliente_id', clientId)
                    .gt('saldo_restante', 0)
                    .order('created_at', { ascending: true });
                if (ve) {
                    showToast('Error obteniendo ventas pendientes: ' + ve.message);
                    return;
                }
                let montoRestante = monto;
                for (const venta of ventasPendientes || []) {
                    if (montoRestante <= 0) break;
                    const pago = Math.min(montoRestante, venta.saldo_restante);
                    // Insertar registro de pago
                    await supabaseClient.from('credit_payments').insert([{ venta_id: venta.id, cliente_id: clientId, monto_pagado: pago, metodo: 'abono' }]);
                    // Actualizar saldo_restante en la venta
                    await supabaseClient.from('ventas').update({ saldo_restante: venta.saldo_restante - pago }).eq('id', venta.id);
                    montoRestante -= pago;
                }
                // Actualizar saldo_pendiente del cliente
                const nuevoSaldo = (client.saldo_pendiente || 0) - monto;
                await supabaseClient.from('clientes').update({ saldo_pendiente: nuevoSaldo < 0 ? 0 : nuevoSaldo }).eq('id', clientId);
                showToast('Pago registrado');
                await openClientsModal();
            } catch (err) {
                console.error(err);
                showToast('Error al registrar el pago');
            }
        }

        /**
         * Abre un modal que muestra las ventas a crédito asociadas a un cliente
         * específico. Incluye información detallada de cada venta (fecha,
         * productos, subtotales en USD y Bs, pagos realizados y saldo
         * restante) y permite anular la venta si fue registrada por error.
         * Sólo los administradores pueden anular una venta.
         *
         * @param {string} clientId Identificador del cliente
         */
        async function openClientDetails(clientId) {
            try {
                // Obtiene el rol del usuario para mostrar botones de anular según corresponda
                await fetchUserRole();
                const client = clients.find(c => c.id === clientId);
                if (!client) {
                    showToast('Cliente no encontrado.');
                    return;
                }
                // Actualiza el título del modal con el nombre del cliente
                const titleEl = document.getElementById('client-details-title');
                if (titleEl) {
                    titleEl.textContent = `Detalles de ${client.nombre}`;
                }
                const bodyEl = document.getElementById('client-details-body');
                if (!bodyEl) return;
                bodyEl.innerHTML = '<p class="text-sm text-text-secondary">Cargando ventas...</p>';
                // Obtiene todas las ventas del cliente
                const { data: sales, error: salesError } = await supabaseClient
                    .from('ventas')
                    .select('id, created_at, total_usd, exchange_rate, saldo_restante')
                    .eq('cliente_id', clientId)
                    .order('created_at', { ascending: false });
                if (salesError) {
                    console.error(salesError);
                    bodyEl.innerHTML = `<p class="text-red-600">Error al cargar ventas: ${salesError.message}</p>`;
                    return;
                }
                if (!sales || sales.length === 0) {
                    bodyEl.innerHTML = '<p class="text-center text-text-secondary">Este cliente no tiene ventas registradas.</p>';
                    openModal('client-details-modal');
                    return;
                }
                // Construye las tarjetas de ventas con su estado y HTML generado
                const salesWithHtml = [];
                for (const sale of sales) {
                    // Cargar items con detalle de productos
                    const { data: items, error: itemsError } = await supabaseClient
                        .from('venta_items')
                        .select('quantity, price, producto_id, productos(name, is_service, stock)')
                        .eq('venta_id', sale.id);
                    if (itemsError) {
                        console.error(itemsError);
                    }
                    // Cargar pagos asociados a esta venta
                    const { data: payments, error: payErr } = await supabaseClient
                        .from('credit_payments')
                        .select('*')
                        .eq('venta_id', sale.id)
                        .order('fecha_pago', { ascending: true });
                    if (payErr) {
                        console.error(payErr);
                    }
                    const rate = sale.exchange_rate || window.exchangeRate;
                    let itemsRows = '';
                    let totalItemsUSD = 0;
                    let totalItemsBs = 0;
                    (items || []).forEach(item => {
                        const productName = item.productos ? item.productos.name : (allProducts.find(p => p.id === item.producto_id)?.name || 'Producto');
                        const priceUSD = item.price;
                        const priceBs = priceUSD * rate;
                        const subUSD = priceUSD * item.quantity;
                        const subBs = subUSD * rate;
                        totalItemsUSD += subUSD;
                        totalItemsBs += subBs;
                        itemsRows += `
                            <tr>
                                <td>${productName}</td>
                                <td class="text-right">${item.quantity}</td>
                                <td class="text-right">${formatCurrency(priceUSD)}</td>
                                <td class="text-right">${formatCurrency(priceBs, 'BS')}</td>
                                <td class="text-right">${formatCurrency(subUSD)}</td>
                                <td class="text-right">${formatCurrency(subBs, 'BS')}</td>
                            </tr>
                        `;
                    });
                    let paymentsHtml = '';
                    let totalPaidUSD = 0;
                    let totalPaidBs = 0;
                    (payments || []).forEach(pay => {
                        totalPaidUSD += pay.monto_pagado;
                        totalPaidBs += pay.monto_pagado * rate;
                        const date = new Date(pay.fecha_pago).toLocaleString('es-VE');
                        paymentsHtml += `<li>${date}: ${formatCurrency(pay.monto_pagado)} / ${formatCurrency(pay.monto_pagado * rate, 'BS')}</li>`;
                    });
                    const saldoBs = sale.saldo_restante * rate;
                    // Determina el estado de la venta.  Utilizamos Number() para
                    // convertir a número y evitar que cadenas "0" se evalúen como
                    // truthy.  Si el saldo restante es mayor que cero, la venta
                    // está pendiente; de lo contrario se considera pagada.
                    const status = (Number(sale.saldo_restante) > 0) ? 'pending' : 'paid';
                    const canDelete = (userRole === 'admin');
                    const deleteBtn = canDelete ? `<button data-sale-id="${sale.id}" data-client-id="${clientId}" class="delete-sale-btn btn btn-danger text-xs ml-2">Anular</button>` : '';
                    const saleHtml = `
                        <div class="border border-border-color rounded-lg p-4 shadow-sm">
                            <div class="flex justify-between items-center">
                                <div>
                                    <h4 class="font-semibold text-lg">Venta del ${new Date(sale.created_at).toLocaleString('es-VE')}</h4>
                                    <p class="text-sm text-text-secondary">Total: ${formatCurrency(sale.total_usd)} / ${formatCurrency(sale.total_usd * rate, 'BS')}</p>
                                </div>
                                <div>
                                    ${deleteBtn}
                                </div>
                            </div>
                            <div class="mt-3">
                                <p class="font-semibold">Productos:</p>
                                <div class="overflow-x-auto">
                                    <table class="w-full text-sm border-collapse mt-1">
                                        <thead>
                                            <tr>
                                                <th>Producto</th>
                                                <th class="text-right">Cant.</th>
                                                <th class="text-right">Precio USD</th>
                                                <th class="text-right">Precio Bs</th>
                                                <th class="text-right">Subtotal USD</th>
                                                <th class="text-right">Subtotal Bs</th>
                                            </tr>
                                        </thead>
                                        <tbody>
                                            ${itemsRows}
                                            <tr class="total-row">
                                                <td colspan="4">Subtotal</td>
                                                <td class="text-right">${formatCurrency(totalItemsUSD)}</td>
                                                <td class="text-right">${formatCurrency(totalItemsBs, 'BS')}</td>
                                            </tr>
                                        </tbody>
                                    </table>
                                </div>
                            </div>
                            <div class="mt-3">
                                <p class="font-semibold">Pagos:</p>
                                ${(paymentsHtml || totalPaidUSD > 0) ? `<ul class="list-disc pl-5 text-sm">${paymentsHtml}</ul>` : '<p class="text-sm text-text-secondary">No hay pagos registrados.</p>'}
                                <p class="mt-1"><strong>Pagado:</strong> ${formatCurrency(totalPaidUSD)} / ${formatCurrency(totalPaidBs, 'BS')}</p>
                                <p><strong>Saldo restante:</strong> ${formatCurrency(sale.saldo_restante)} / ${formatCurrency(saldoBs, 'BS')}</p>
                            </div>
                        </div>
                    `;
                    salesWithHtml.push({ status, html: saleHtml });
                }
                // Función para renderizar ventas según filtro seleccionado
                const renderClientSales = (filter = 'all') => {
                    let rendered = '';
                    salesWithHtml.forEach(entry => {
                        if (filter === 'all' || (filter === 'pending' && entry.status === 'pending') || (filter === 'paid' && entry.status === 'paid')) {
                            rendered += entry.html;
                        }
                    });
                    if (!rendered) {
                        rendered = '<p class="text-center text-text-secondary">No hay ventas que coincidan con el filtro.</p>';
                    }
                    bodyEl.innerHTML = rendered;
                    // Asigna eventos para anular
                    bodyEl.querySelectorAll('.delete-sale-btn').forEach(btn => {
                        btn.addEventListener('click', async e => {
                            const saleId = e.currentTarget.dataset.saleId;
                            const cId = e.currentTarget.dataset.clientId;
                            await deleteSale(saleId, cId);
                        });
                    });
                };
                // Render inicial
                renderClientSales('all');
                // Asigna el selector de filtro
                const filterSelect = document.getElementById('client-details-filter');
                if (filterSelect) {
                    // Restablece el selector al valor por defecto ('all') cada vez que se abre el modal
                    filterSelect.value = 'all';
                    filterSelect.onchange = null;
                    filterSelect.addEventListener('change', e => {
                        const val = e.target.value;
                        renderClientSales(val);
                    });
                }
                // Cierra cualquier modal anterior antes de abrir detalles, para evitar superposiciones de fondo difuminado
                closeModal();
                openModal('client-details-modal');
            } catch (err) {
                console.error(err);
                showToast('Error al cargar los detalles del cliente.');
            }
        }

        /**
         * Anula una venta específica. Este proceso incrementa el stock de los
         * productos (excepto servicios), actualiza el saldo pendiente del
         * cliente y elimina la venta junto con sus items y pagos asociados.
         * Sólo debe utilizarse por administradores para corregir errores.
         *
         * @param {string} saleId Identificador de la venta
         * @param {string} clientId Identificador del cliente
         */
        async function deleteSale(saleId, clientId) {
            try {
                if (userRole !== 'admin') {
                    showToast('Sólo los administradores pueden anular ventas.');
                    return;
                }
                const confirmDelete = confirm('¿Seguro que deseas anular esta venta? Esta acción no se puede deshacer.');
                if (!confirmDelete) return;
                // Obtiene la venta y su saldo restante
                const { data: sale, error: saleErr } = await supabaseClient
                    .from('ventas')
                    .select('id, saldo_restante')
                    .eq('id', saleId)
                    .single();
                if (saleErr || !sale) {
                    showToast('No se pudo encontrar la venta a anular.');
                    return;
                }
                // Obtiene los items de la venta con información de productos
                const { data: items, error: itemsErr } = await supabaseClient
                    .from('venta_items')
                    .select('producto_id, quantity, productos(is_service, stock)')
                    .eq('venta_id', saleId);
                if (itemsErr) {
                    console.error(itemsErr);
                    showToast('Error al obtener items de la venta.');
                    return;
                }
                // Incrementa el stock de los productos no servicio
                for (const it of items || []) {
                    const isService = it.productos ? it.productos.is_service : (allProducts.find(p => p.id === it.producto_id)?.is_service);
                    if (!isService) {
                        let currentStock = it.productos ? it.productos.stock : null;
                        if (currentStock === null || currentStock === undefined) {
                            const { data: prod } = await supabaseClient.from('productos').select('stock').eq('id', it.producto_id).single();
                            currentStock = prod ? prod.stock : 0;
                        }
                        const newStock = (currentStock || 0) + Number(it.quantity);
                        await supabaseClient.from('productos').update({ stock: newStock }).eq('id', it.producto_id);
                    }
                }
                // Actualiza el saldo pendiente del cliente restando el saldo_restante de la venta
                if (clientId) {
                    const client = clients.find(c => c.id === clientId);
                    let nuevoSaldo = (client ? client.saldo_pendiente : 0) - (sale.saldo_restante || 0);
                    if (nuevoSaldo < 0) nuevoSaldo = 0;
                    await supabaseClient.from('clientes').update({ saldo_pendiente: nuevoSaldo }).eq('id', clientId);
                }
                // Elimina la venta (los items y pagos se eliminan por cascada)
                await supabaseClient.from('ventas').delete().eq('id', saleId);
                showToast('Venta anulada correctamente.');
                // Recarga datos de clientes y detalles si están abiertos
                await fetchClients();
                if (document.getElementById('client-details-modal') && !document.getElementById('client-details-modal').classList.contains('hidden')) {
                    await openClientDetails(clientId);
                }
                if (document.getElementById('clients-modal') && !document.getElementById('clients-modal').classList.contains('hidden')) {
                    renderClientsList();
                }
            } catch (err) {
                console.error(err);
                showToast('Error al anular la venta.');
            }
        }

        /**
         * Abre el modal de venta a crédito.  Si no hay clientes registrados,
         * solicita al usuario crear uno primero.  De lo contrario, muestra
         * un selector de clientes y el total de la venta actual.
         */
        async function openCreditSaleModal() {
            await fetchClients();
            if (!clients || clients.length === 0) {
                showToast('Debe registrar al menos un cliente para realizar ventas a crédito.');
                return;
            }
            const selectEl = document.getElementById('credit-client-select');
            if (selectEl) {
                selectEl.innerHTML = clients.map(c => `<option value="${c.id}">${c.nombre} (Saldo: ${formatCurrency(c.saldo_pendiente)})</option>`).join('');
            }
            const totalUSD = window.cart.reduce((s, it) => s + (it.price * it.quantity), 0);
            document.getElementById('credit-sale-total').textContent = formatCurrency(totalUSD);
            openModal('credit-sale-modal');
        }

        /**
         * Abre el modal de opciones de resumen de ventas, permitiendo
         * seleccionar el periodo y el filtro de método de pago. Al
         * confirmar se llama a exportSalesSummaryCustom() con los valores
         * seleccionados.
         */
        function openSummaryOptionsModal() {
            const daysSelect = document.getElementById('summary-days');
            const paymentSelect = document.getElementById('summary-payment-filter');
            const confirmBtn = document.getElementById('confirm-summary-options-btn');
            if (!daysSelect || !paymentSelect || !confirmBtn) {
                // Si el modal no existe, se utiliza la versión con prompts
                exportSalesSummaryCustom();
                return;
            }
            // establece valores por defecto
            daysSelect.value = '1';
            paymentSelect.value = '';
            // Elimina eventos previos para evitar duplicados
            confirmBtn.onclick = null;
            confirmBtn.addEventListener('click', () => {
                const days = parseInt(daysSelect.value, 10);
                const payFilter = paymentSelect.value || '';
                // Cierra el modal de opciones antes de generar el resumen
                closeModal();
                // Genera y muestra el resumen dentro de su propio modal
                openSalesSummaryModal(days, payFilter);
            });
            openModal('summary-options-modal');
        }

        /**
         * Abre el modal de gestión de ventas. Permite ver el historial de ventas,
         * filtrar por método de pago y estado, y anular ventas desde un panel
         * general. Sólo los administradores pueden anular ventas.
         */
        async function openSalesManagementModal() {
            try {
                await fetchUserRole();
                // Referencias a elementos del modal
                const tbody = document.getElementById('sales-management-body');
                const paySelect = document.getElementById('sales-filter-payment');
                const statusSelect = document.getElementById('sales-filter-status');
                if (!tbody || !paySelect || !statusSelect) {
                    showToast('No se encontró la interfaz de gestión de ventas.');
                    return;
                }
                // Cierra cualquier modal abierto antes de abrir la gestión de ventas
                closeModal();
                // Mostrar inmediatamente el modal para que el usuario vea la pantalla en lugar de un fondo difuminado sin contenido
                openModal('sales-management-modal');
                tbody.innerHTML = '<tr><td colspan="7" class="text-center py-4">Cargando...</td></tr>';
                // Obtener todas las ventas con el nombre del cliente mediante relación
                const { data: sales, error } = await supabaseClient
                    .from('ventas')
                    .select('id, created_at, total_usd, exchange_rate, saldo_restante, payment_methods, cliente_id, clientes(nombre)')
                    .order('created_at', { ascending: false });
                if (error) {
                    console.error(error);
                    tbody.innerHTML = '<tr><td colspan="7" class="text-center py-4 text-red-600">Error al cargar ventas.</td></tr>';
                    return;
                }
                if (!sales || sales.length === 0) {
                    tbody.innerHTML = '<tr><td colspan="7" class="text-center py-4">No hay ventas registradas.</td></tr>';
                    openModal('sales-management-modal');
                    return;
                }
                // Construir un arreglo de ventas con datos calculados
                const allSales = sales.map(sale => {
                    const rate = sale.exchange_rate || window.exchangeRate;
                    const totalBs = (sale.total_usd || 0) * rate;
                    const methods = sale.payment_methods ? Object.keys(sale.payment_methods).join(', ') : '';
                    const status = (sale.saldo_restante && sale.saldo_restante > 0) ? 'pending' : 'paid';
                    const clientName = sale.clientes ? sale.clientes.nombre : 'N/A';
                    return {
                        id: sale.id,
                        date: new Date(sale.created_at).toLocaleString('es-VE'),
                        totalUSD: sale.total_usd || 0,
                        totalBs: totalBs,
                        methods: methods,
                        status: status,
                        clientId: sale.cliente_id,
                        clientName: clientName,
                        saldoRestante: sale.saldo_restante || 0
                    };
                });
                // Función para renderizar la tabla según filtros
                const renderSalesTable = () => {
                    const filterPay = (paySelect.value || '').toLowerCase();
                    const filterStatus = statusSelect.value;
                    let html = '';
                    allSales.forEach(sale => {
                        // Filtra por método de pago
                        if (filterPay && !sale.methods.toLowerCase().includes(filterPay)) return;
                        // Filtra por estado
                        if (filterStatus !== 'all' && sale.status !== filterStatus) return;
                        const statusLabel = sale.status === 'pending' ? 'Pendiente' : 'Pagada';
                        const deleteButton = (userRole === 'admin') ? `<button data-sale-id="${sale.id}" data-client-id="${sale.clientId}" class="delete-sale-btn btn btn-danger btn-xs">Anular</button>` : '';
                        html += `
                            <tr>
                                <td>${sale.date}</td>
                                <td>${sale.clientName}</td>
                                <td class="text-right">${formatCurrency(sale.totalUSD)}</td>
                                <td class="text-right">${formatCurrency(sale.totalBs, 'BS')}</td>
                                <td>${sale.methods || '-'}</td>
                                <td>${statusLabel}</td>
                                <td>${deleteButton}</td>
                            </tr>
                        `;
                    });
                    if (!html) {
                        html = '<tr><td colspan="7" class="text-center py-4">No hay ventas que coincidan con el filtro.</td></tr>';
                    }
                    tbody.innerHTML = html;
                    // Reasignar eventos a botones de anular
                    tbody.querySelectorAll('.delete-sale-btn').forEach(btn => {
                        btn.addEventListener('click', async e => {
                            const saleId = e.currentTarget.dataset.saleId;
                            const clientId = e.currentTarget.dataset.clientId;
                            await deleteSale(saleId, clientId);
                            // Después de anular la venta, quitarla de allSales y volver a renderizar
                            const index = allSales.findIndex(s => s.id === saleId);
                            if (index > -1) {
                                allSales.splice(index, 1);
                            }
                            renderSalesTable();
                        });
                    });
                };
                // Asociar eventos a los selectores de filtro
                paySelect.onchange = null;
                statusSelect.onchange = null;
                paySelect.addEventListener('change', renderSalesTable);
                statusSelect.addEventListener('change', renderSalesTable);
                // Renderizar la tabla al finalizar la carga
                renderSalesTable();
            } catch (err) {
                console.error(err);
                showToast('Error al gestionar ventas.');
            }
        }

        /**
         * Registra una venta a crédito.  Se inserta la venta con el saldo
         * restante igual al total, se insertan los items, se decrementa el
         * stock y se actualiza el saldo_pendiente del cliente.  Requiere que
         * el usuario esté autenticado como vendedor o administrador.
         */
        async function recordCreditSale(clienteId) {
            try {
                if (!session) {
                    const storedId = localStorage.getItem('userId');
                    if (storedId) {
                        session = { user: { id: storedId } };
                    } else {
                        throw new Error('Debes iniciar sesión para esta acción');
                    }
                }
                const ventaId = 'c_' + Date.now();
                const totalUSD = window.cart.reduce((s,it) => s + (it.price * it.quantity), 0);
                const paymentMethods = { credit: totalUSD };
                const venta = {
                    id: ventaId,
                    total_usd: totalUSD,
                    exchange_rate: window.exchangeRate,
                    items: window.cart.length,
                    payment_methods: paymentMethods,
                    cliente_id: clienteId,
                    saldo_restante: totalUSD,
                    seller_id: session.user.id
                };
                const items = window.cart.map(it => ({ venta_id: ventaId, producto_id: it.id, quantity: it.quantity, price: it.price }));
                const { error: err1 } = await supabaseClient.from('ventas').insert([venta]);
                if (err1) { showToast('Error al registrar venta: ' + err1.message); return; }
                if (items.length) {
                    const { error: err2 } = await supabaseClient.from('venta_items').insert(items);
                    if (err2) { showToast('Error al registrar items: ' + err2.message); return; }
                }
                // Decrementar stock para cada item (excepto servicios)
                for (const it of window.cart) {
                    if (!it.is_service) {
                        await supabaseClient.rpc('decrement_stock', { product_id: it.id, decrement_value: it.quantity });
                    }
                }
                // Actualizar saldo_pendiente del cliente
                const client = clients.find(c => c.id === clienteId);
                const nuevoSaldo = ((client && client.saldo_pendiente) || 0) + totalUSD;
                await supabaseClient.from('clientes').update({ saldo_pendiente: nuevoSaldo }).eq('id', clienteId);
                // Limpia el carrito y actualiza UI
                window.cart = [];
                renderCart();
                showToast('Venta a crédito registrada');
                // Cerrar modal y recargar lista de clientes
                await openClientsModal();
            } catch (err) {
                console.error(err);
                showToast('Error al registrar venta a crédito');
            }
        }
        
        function waChoice(){
            return new Promise(resolve=>{
                const wrap=document.createElement('div');
                wrap.className = 'modal-overlay-bg fixed inset-0 flex items-center justify-center z-50';
                wrap.innerHTML=`<div class="bg-secondary rounded-lg p-4 w-full max-w-xs shadow-xl">
                    <h3 class="font-bold text-lg mb-2">Enviar por WhatsApp</h3>
                    <p class="text-sm mb-4 text-text-secondary">¿Cómo quieres enviar este ticket?</p>
                    <div class="flex flex-col gap-2">
                        <button id="wa-presupuesto" class="btn btn-secondary w-full">Solo Presupuesto</button>
                        <button id="wa-venta" class="btn btn-primary w-full">Finalizar Venta y Enviar</button>
                    </div>
                    <div class="mt-4 text-center"><button id="wa-cancel" class="btn btn-text text-sm">Cancelar</button></div>
                </div>`;
                document.body.appendChild(wrap);
                const close=v=>{ wrap.remove(); resolve(v); };
                wrap.querySelector('#wa-presupuesto').onclick=()=>close('presupuesto');
                wrap.querySelector('#wa-venta').onclick=()=>close('venta');
                wrap.querySelector('#wa-cancel').onclick=()=>close(null);
            });
        }

        async function exportSalesSummary() {
            if (!session) { showToast('Debes iniciar sesión para ver el resumen.'); return; }

            const startOfDay = new Date();
            startOfDay.setHours(0, 0, 0, 0);

            try {
                const { data: sales, error } = await supabaseClient
                    .from('ventas')
                    .select('*, venta_items(*, productos(name))')
                    .gte('created_at', startOfDay.toISOString())
                    .order('created_at', { ascending: false });

                if (error) throw error;
                if (!sales || sales.length === 0) {
                    showToast('No hay ventas registradas hoy.');
                    return;
                }

                let totalDayUSD = 0;
                let totalDayBs = 0;
                let reportHtml = '';
                // Para cada venta sumarizamos productos y calculamos valores en USD y Bs
                sales.forEach(sale => {
                    totalDayUSD += sale.total_usd;
                    const rate = sale.exchange_rate || window.exchangeRate;
                    totalDayBs += sale.total_usd * rate;
                    (sale.venta_items || []).forEach(item => {
                        const productName = item.productos ? item.productos.name : 'Producto Eliminado';
                        const priceUSD = item.price;
                        const priceBs = priceUSD * rate;
                        const subTotalUSD = item.quantity * priceUSD;
                        const subTotalBs = subTotalUSD * rate;
                        reportHtml += `
                                <tr>
                                    <td>${new Date(sale.created_at).toLocaleTimeString('es-VE')}</td>
                                    <td>${productName}</td>
                                    <td class="text-right">${item.quantity}</td>
                                    <td class="text-right">${formatCurrency(priceUSD)}</td>
                                    <td class="text-right">${formatCurrency(priceBs, 'BS')}</td>
                                    <td class="text-right">${formatCurrency(subTotalUSD)}</td>
                                    <td class="text-right">${formatCurrency(subTotalBs, 'BS')}</td>
                                </tr>
                        `;
                    });
                });

                const fullHtml = `
                    <html>
                    <head>
                        <title>Resumen de Ventas - ${new Date().toLocaleDateString('es-VE')}</title>
                        <style>
                            body { font-family: sans-serif; margin: 20px; }
                            table { width: 100%; border-collapse: collapse; }
                            th, td { border: 1px solid #ddd; padding: 8px; }
                            th { background-color: #f2f2f2; text-align: left; }
                            .text-right { text-align: right; }
                            h1, h2 { text-align: center; }
                            .total-row { font-weight: bold; background-color: #f9f9f9; }
                        </style>
                    </head>
                    <body>
                        <h1>Resumen de Ventas</h1>
                        <h2>${new Date().toLocaleDateString('es-VE')}</h2>
                        <table>
                            <thead>
                                <tr>
                                    <th>Hora</th>
                                    <th>Producto</th>
                                    <th class="text-right">Cantidad</th>
                                    <th class="text-right">Precio USD</th>
                                    <th class="text-right">Precio Bs</th>
                                    <th class="text-right">Subtotal USD</th>
                                    <th class="text-right">Subtotal Bs</th>
                                </tr>
                            </thead>
                            <tbody>
                                ${reportHtml}
                                <tr class="total-row">
                                    <td colspan="6">TOTAL DEL DÍA (USD)</td>
                                    <td class="text-right">${formatCurrency(totalDayUSD)}</td>
                                </tr>
                                <tr class="total-row">
                                    <td colspan="6">TOTAL DEL DÍA (Bs)</td>
                                    <td class="text-right">${formatCurrency(totalDayBs, 'BS')}</td>
                                </tr>
                            </tbody>
                        </table>
                    </body>
                    </html>
                `;

                const win = window.open('', '_blank');
                win.document.write(fullHtml);
                win.document.close();
                win.print();

            } catch (error) {
                console.error("Error creating sales summary:", error);
                showToast("Error al generar el resumen: " + error.message, 5000);
            }
        }
        
        // Nueva versión de exportSalesSummary con rango de fechas (1, 7, 15 o 30 días) y filtro por método de pago.  Esta función utiliza prompts para solicitar parámetros al administrador.
        async function exportSalesSummaryCustom() {
            // Esta función puede recibir parámetros opcionales (daysParam, paymentFilterParam)
            // para evitar los prompts. Si no se proporcionan, se usarán prompts predeterminados.
            const args = arguments;
            if (!session) { showToast('Debes iniciar sesión para ver el resumen.'); return; }
            let days, paymentFilter;
            if (args.length > 0 && typeof args[0] !== 'undefined' && args[0] !== null) {
                days = parseInt(args[0], 10);
            }

        /**
         * Genera un resumen de ventas dentro de un modal.  A diferencia de
         * exportSalesSummaryCustom(), este método muestra los resultados
         * en la interfaz en lugar de abrir una nueva ventana, lo que
         * proporciona una experiencia más fluida y evita problemas con
         * ventanas emergentes bloqueadas.
         *
         * @param {number} days Número de días hacia atrás desde hoy para el
         *    periodo del resumen (1, 7, 15, 30).
         * @param {string} paymentFilter Cadena opcional con el nombre del
         *    método de pago (por ejemplo "efectivo_usd", "zelle").
         */
        async function openSalesSummaryModal(days = 1, paymentFilter = '') {
            if (!session) {
                showToast('Debes iniciar sesión para ver el resumen.');
                return;
            }
            // Determinar fecha de inicio
            const startDate = new Date();
            startDate.setHours(0, 0, 0, 0);
            startDate.setDate(startDate.getDate() - (days - 1));
            try {
                const { data: sales, error } = await supabaseClient
                    .from('ventas')
                    .select('*, venta_items(*, productos(name))')
                    .gte('created_at', startDate.toISOString())
                    .order('created_at', { ascending: false });
                if (error) throw error;
                if (!sales || sales.length === 0) {
                    showToast('No hay ventas registradas en el periodo seleccionado.');
                    return;
                }
                let filteredSales = sales;
                const normalizedFilter = (paymentFilter || '').toLowerCase();
                if (normalizedFilter) {
                    filteredSales = sales.filter(sale => {
                        try {
                            const methods = sale.payment_methods || {};
                            return Object.keys(methods).some(key => key.toLowerCase().includes(normalizedFilter));
                        } catch {
                            return false;
                        }
                    });
                    if (filteredSales.length === 0) {
                        showToast('No hay ventas para el tipo de pago seleccionado.');
                        return;
                    }
                }
                let totalUSD = 0;
                let totalBs = 0;
                let rowsHtml = '';
                filteredSales.forEach(sale => {
                    totalUSD += sale.total_usd;
                    totalBs += sale.total_usd * (sale.exchange_rate || window.exchangeRate);
                    (sale.venta_items || []).forEach(item => {
                        const productName = item.productos ? item.productos.name : 'Producto Eliminado';
                        const priceUSD = item.price;
                        const rate = sale.exchange_rate || window.exchangeRate;
                        const priceBs = priceUSD * rate;
                        const subUSD = item.quantity * priceUSD;
                        const subBs = subUSD * rate;
                        rowsHtml += `
                            <tr>
                                <td>${new Date(sale.created_at).toLocaleString('es-VE')}</td>
                                <td>${productName}</td>
                                <td class="text-right">${item.quantity}</td>
                                <td class="text-right">${formatCurrency(priceUSD)}</td>
                                <td class="text-right">${formatCurrency(priceBs, 'BS')}</td>
                                <td class="text-right">${formatCurrency(subUSD)}</td>
                                <td class="text-right">${formatCurrency(subBs, 'BS')}</td>
                            </tr>
                        `;
                    });
                });
                // Construir tabla y título
                const endDate = new Date();
                const rangeLabel = `${startDate.toLocaleDateString('es-VE')} – ${endDate.toLocaleDateString('es-VE')}`;
                const tableHtml = `
                    <table class="w-full text-sm border-collapse">
                        <thead>
                            <tr>
                                <th>Fecha y Hora</th>
                                <th>Producto</th>
                                <th class="text-right">Cantidad</th>
                                <th class="text-right">Precio USD</th>
                                <th class="text-right">Precio Bs</th>
                                <th class="text-right">Subtotal USD</th>
                                <th class="text-right">Subtotal Bs</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${rowsHtml}
                            <tr class="total-row">
                                <td colspan="6">TOTAL PERIODO (USD)</td>
                                <td class="text-right">${formatCurrency(totalUSD)}</td>
                            </tr>
                            <tr class="total-row">
                                <td colspan="6">TOTAL PERIODO (Bs)</td>
                                <td class="text-right">${formatCurrency(totalBs, 'BS')}</td>
                            </tr>
                        </tbody>
                    </table>
                `;
                // Actualizar título y contenido del modal
                const titleEl = document.getElementById('sales-summary-title');
                const contentEl = document.getElementById('sales-summary-content');
                if (titleEl) {
                    titleEl.innerHTML = `Resumen de Ventas<br><span class="text-sm font-normal">${rangeLabel}${paymentFilter ? ' • ' + paymentFilter : ''}</span>`;
                }
                if (contentEl) {
                    contentEl.innerHTML = tableHtml;
                }
                // Guardar html completo para imprimir
                const printableHtml = `<!DOCTYPE html><html><head><meta charset="utf-8"><title>Resumen de Ventas</title>
                    <style>body{font-family:sans-serif;margin:20px;}table{width:100%;border-collapse:collapse;}th,td{border:1px solid #ddd;padding:8px;}th{background-color:#f2f2f2;} .text-right{text-align:right;} .total-row{font-weight:bold;background-color:#f9f9f9;}</style>
                    </head><body><h1>Resumen de Ventas</h1><h2>${rangeLabel}</h2>${paymentFilter ? `<p><strong>Tipo de pago:</strong> ${paymentFilter}</p>` : ''}${tableHtml}</body></html>`;
                // Asignar evento de impresión
                const printBtn = document.getElementById('print-sales-summary-btn');
                if (printBtn) {
                    printBtn.onclick = () => {
                        const win = window.open('', '_blank');
                        if (!win) {
                            showToast('No se pudo abrir la ventana de impresión.');
                            return;
                        }
                        win.document.write(printableHtml);
                        win.document.close();
                        win.print();
                    };
                }
                // Mostrar el modal: cierra cualquier otro modal abierto antes de abrir el resumen
                closeModal();
                openModal('sales-summary-modal');
            } catch (err) {
                console.error(err);
                showToast('Error al generar el resumen.');
            }
        }
            if (args.length > 1 && typeof args[1] !== 'undefined' && args[1] !== null) {
                paymentFilter = String(args[1]).trim().toLowerCase();
            }
            if (!days) {
                const daysInput = prompt('Mostrar ventas de los últimos días (elige 1, 7, 15 o 30):', '1');
                if (daysInput === null) return;
                days = parseInt(daysInput, 10);
                if (isNaN(days) || ![1, 7, 15, 30].includes(days)) {
                    days = 1;
                }
            }
            if (typeof paymentFilter === 'undefined') {
                let pf = prompt('Filtrar por tipo de pago (opcional). Usa valores como "efectivo_usd", "efectivo_bs", "zelle", "tarjeta", "pago_movil". Deja vacío para incluir todos:', '');
                if (pf === null) return;
                paymentFilter = (pf || '').trim().toLowerCase();
            }
            const startDate = new Date();
            startDate.setHours(0, 0, 0, 0);
            startDate.setDate(startDate.getDate() - (days - 1));
            try {
                const { data: sales, error } = await supabaseClient
                    .from('ventas')
                    .select('*, venta_items(*, productos(name))')
                    .gte('created_at', startDate.toISOString())
                    .order('created_at', { ascending: false });
                if (error) throw error;
                if (!sales || sales.length === 0) {
                    showToast('No hay ventas registradas en el periodo seleccionado.');
                    return;
                }
                let filteredSales = sales;
                if (paymentFilter) {
                    // Permitir coincidencias parciales: por ejemplo, "efectivo" coincidirá con "efectivo_usd" y "efectivo_bs".
                    const normalizedFilter = paymentFilter.toLowerCase();
                    filteredSales = sales.filter(sale => {
                        try {
                            const methods = sale.payment_methods || {};
                            return Object.keys(methods).some(key => key.toLowerCase().includes(normalizedFilter));
                        } catch {
                            return false;
                        }
                    });
                    if (filteredSales.length === 0) {
                        showToast('No hay ventas para el tipo de pago seleccionado.');
                        return;
                    }
                }
                let totalUSD = 0;
                let totalBs = 0;
                let reportHtml = '';
                filteredSales.forEach(sale => {
                    totalUSD += sale.total_usd;
                    totalBs += sale.total_usd * (sale.exchange_rate || window.exchangeRate);
                    (sale.venta_items || []).forEach(item => {
                        const productName = item.productos ? item.productos.name : 'Producto Eliminado';
                        const priceUSD = item.price;
                        const rate = sale.exchange_rate || window.exchangeRate;
                        const priceBs = priceUSD * rate;
                        const subTotalUSD = item.quantity * priceUSD;
                        const subTotalBs = subTotalUSD * rate;
                        reportHtml += `
                            <tr>
                                <td>${new Date(sale.created_at).toLocaleString('es-VE')}</td>
                                <td>${productName}</td>
                                <td class="text-right">${item.quantity}</td>
                                <td class="text-right">${formatCurrency(priceUSD)}</td>
                                <td class="text-right">${formatCurrency(priceBs, 'BS')}</td>
                                <td class="text-right">${formatCurrency(subTotalUSD)}</td>
                                <td class="text-right">${formatCurrency(subTotalBs, 'BS')}</td>
                            </tr>
                        `;
                    });
                });
                const endDate = new Date();
                const rangeLabel = `${startDate.toLocaleDateString('es-VE')} – ${endDate.toLocaleDateString('es-VE')}`;
                const fullHtml = `
                    <html>
                    <head>
                        <title>Resumen de Ventas - ${rangeLabel}</title>
                        <style>
                            body { font-family: sans-serif; margin: 20px; }
                            table { width: 100%; border-collapse: collapse; }
                            th, td { border: 1px solid #ddd; padding: 8px; }
                            th { background-color: #f2f2f2; text-align: left; }
                            .text-right { text-align: right; }
                            h1, h2 { text-align: center; }
                            .total-row { font-weight: bold; background-color: #f9f9f9; }
                        </style>
                    </head>
                    <body>
                        <h1>Resumen de Ventas</h1>
                        <h2>${rangeLabel}</h2>
                        ${paymentFilter ? `<p><strong>Tipo de pago:</strong> ${paymentFilter}</p>` : ''}
                        <table>
                            <thead>
                                <tr>
                                <th>Fecha y Hora</th>
                                <th>Producto</th>
                                <th class="text-right">Cantidad</th>
                                <th class="text-right">Precio USD</th>
                                <th class="text-right">Precio Bs</th>
                                <th class="text-right">Subtotal USD</th>
                                <th class="text-right">Subtotal Bs</th>
                                </tr>
                            </thead>
                            <tbody>
                                ${reportHtml}
                                <tr class="total-row">
                                    <td colspan="6">TOTAL PERIODO (USD)</td>
                                    <td class="text-right">${formatCurrency(totalUSD)}</td>
                                </tr>
                                <tr class="total-row">
                                    <td colspan="6">TOTAL PERIODO (Bs)</td>
                                    <td class="text-right">${formatCurrency(totalBs, 'BS')}</td>
                                </tr>
                            </tbody>
                        </table>
                    </body>
                    </html>
                `;
                const win = window.open('', '_blank');
                if (!win) {
                    showToast('No se pudo abrir la ventana para el resumen.');
                    return;
                }
                win.document.write(fullHtml);
                win.document.close();
                win.print();
            } catch (error) {
                console.error('Error creando resumen de ventas:', error);
                showToast('Error al generar el resumen: ' + (error.message || ''), 5000);
            }
        }

        async function syncProductsFromSupabase() {
            if (!navigator.onLine) {
                console.log("Offline mode: Skipping Supabase sync.");
                return;
            }
            try {
                const { data, error } = await supabaseClient.from('productos').select('*').order('name');
                if (error) throw error;
                allProducts = data;
                localStorage.setItem('products', JSON.stringify(allProducts));
                renderProducts();
                renderCategoryFilters();
                await ensureProductsSynced();
            } catch(error) {
                console.error('Error syncing products from Supabase:', error);
            }
        }

        function loadProductsFromLocal() {
            try {
                const localProducts = JSON.parse(localStorage.getItem('products') || '[]');
                if (Array.isArray(localProducts) && localProducts.length > 0) {
                    allProducts = localProducts;
                }
            } catch(e) {
                console.error("Could not load products from local storage", e);
                allProducts = [];
            }
            renderProducts();
            renderCategoryFilters();
        }

        function listenToProductChanges() {
            if (window.productChangesSubscription) {
                window.productChangesSubscription.unsubscribe();
            }
            
            window.productChangesSubscription = supabaseClient
                .channel('public:productos')
                .on('postgres_changes', { event: '*', schema: 'public', table: 'productos' }, payload => {
                    console.log('Realtime change received!', payload);
                    const { eventType, new: newRecord, old: oldRecord } = payload;
                    
                    if (eventType === 'INSERT') {
                        allProducts.push(newRecord);
                    }
                    if (eventType === 'UPDATE') {
                        const index = allProducts.findIndex(p => p.id === newRecord.id);
                        if (index > -1) allProducts[index] = newRecord;
                    }
                    if (eventType === 'DELETE') {
                        allProducts = allProducts.filter(p => p.id !== oldRecord.id);
                    }

                    localStorage.setItem('products', JSON.stringify(allProducts));
                    filterProducts();
                    renderCategoryFilters();

                    if (currentModal === 'product-management-modal') {
                        renderProductManagementList();
                        renderCategoryManagementList();
                    }
                })
                .subscribe();
        }

        async function initializeApp() {
            Theme.apply(localStorage.getItem('theme') || 'light');
            fetchAndUpdateExchangeRate(); 
            setInterval(fetchAndUpdateExchangeRate, 3600000);
            
            loadProductsFromLocal();

            const { data: { session: initialSession } } = await supabaseClient.auth.getSession();
            session = initialSession;
            // If there is no active session (offline or not logged in), attempt
            // to restore the previous user id and role from localStorage so
            // the app remains functional offline.  This allows recording
            // offline sales even after a refresh without re‑authenticating.
            if (!session) {
                const storedId = localStorage.getItem('userId');
                const storedRole = localStorage.getItem('userRole');
                if (storedId) {
                    session = { user: { id: storedId } };
                    userRole = storedRole || null;
                }
            }
            lockUIBySession();
            // Fetch the role from Supabase only if we have a session and
            // online connectivity.  Otherwise fallback to stored role.
            if (session && navigator.onLine) {
                await fetchUserRole();
            }
            if (!userRole) {
                try { userRole = localStorage.getItem('userRole') || null; } catch {}
            }
            updateUIByRole();
            await syncProductsFromSupabase();
            listenToProductChanges();

            supabaseClient.auth.onAuthStateChange((_event, newSession) => { 
                const sessionChanged = session?.user?.id !== newSession?.user?.id;
                session = newSession; 
                lockUIBySession();
                // Refresh user role and update UI whenever the auth session changes
                if (session) {
                    fetchUserRole().then(updateUIByRole);
                } else {
                    userRole = null;
                    updateUIByRole();
                }
                if (sessionChanged && newSession) {
                    // If a different user just signed in, resync products and subscribe to changes
                    syncProductsFromSupabase();
                    listenToProductChanges();
                } else if (!newSession && sessionChanged) {
                    // If the user just signed out, resync products for public catalog and keep listening
                    syncProductsFromSupabase();
                    listenToProductChanges();
                }
            });

            window.addEventListener('beforeinstallprompt', (event) => {
                event.preventDefault();
                deferredInstallPrompt = event;
                DOM.installAppBtn.classList.remove('hidden');
            });

            DOM.installAppBtn.addEventListener('click', async () => {
                if (deferredInstallPrompt) {
                    deferredInstallPrompt.prompt();
                    await deferredInstallPrompt.userChoice;
                    deferredInstallPrompt = null;
                    DOM.installAppBtn.classList.add('hidden');
                }
            });

            if ('serviceWorker' in navigator) {
                window.addEventListener('load', () => {
                    location.hostname.match(/^(127\.0\.0\.1|localhost)$/) ? Promise.resolve() : navigator.serviceWorker.register('./sw.js').then(reg => {
                        console.log('Service worker registered!', reg);
                    }).catch(err => {
                        console.log('Service worker registration failed: ', err);
                    });
                });
            }
            __offlineQueue.start();
        }

        document.addEventListener('DOMContentLoaded', () => {
            if (!SUPABASE_URL || !SUPABASE_ANON_KEY) { document.getElementById('config-error').classList.remove('hidden'); return; }
            window.supabaseClient = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
            
            const closeCartDrawer = () => DOM.cartDrawer.classList.replace('open', 'closed');

            DOM.themeToggleBtn.addEventListener('click', () => Theme.toggle());
            DOM.viewToggleBtn.addEventListener('click', () => {
                DOM.productGrid.classList.toggle('list-view');
                DOM.viewToggleBtn.innerHTML = DOM.productGrid.classList.contains('list-view') ? '<i class="fas fa-th-large"></i>' : '<i class="fas fa-grip-vertical"></i>';
            });
            DOM.searchInput.addEventListener('input', filterProducts);
            DOM.authButton.addEventListener('click', () => openModal('auth-modal'));
            document.getElementById('cart-button').addEventListener('click', () => DOM.cartDrawer.classList.replace('closed', 'open'));
            document.getElementById('close-cart-button').addEventListener('click', closeCartDrawer);
            DOM.modalContainer.addEventListener('click', e => { if (e.target === DOM.modalContainer || e.target.closest('.btn-close-modal')) closeModal(); });
            
            DOM.bcvToggleBtn.addEventListener('click', () => {
                isBcvAuto = !isBcvAuto;
                DOM.exchangeRateInput.readOnly = isBcvAuto;
                DOM.exchangeRateInput.classList.toggle('bg-gray-200', isBcvAuto);
                DOM.exchangeRateInput.classList.toggle('dark:bg-gray-600', isBcvAuto);
                DOM.exchangeRateInput.classList.toggle('bg-white', !isBcvAuto);
                DOM.exchangeRateInput.classList.toggle('dark:bg-gray-700', !isBcvAuto);
                DOM.bcvToggleBtn.classList.toggle('text-green-500', isBcvAuto);
                if (isBcvAuto) {
                    fetchAndUpdateExchangeRate();
                } else {
                     document.getElementById('rate-last-update').textContent = 'Entrada manual';
                }
            });
            DOM.exchangeRateInput.addEventListener('input', () => {
                if (!isBcvAuto) { renderCart(); filterProducts(); }
            });

            document.getElementById('login-form').addEventListener('submit', async e => {
                e.preventDefault();
                const { error } = await supabaseClient.auth.signInWithPassword({ email: document.getElementById('email').value, password: document.getElementById('password').value });
                if (error) showToast('Error: ' + error.message); else { showToast('Sesión iniciada.'); closeModal(); }
            });
            document.getElementById('logout-button').addEventListener('click', async () => {
                if (await showConfirmation('¿Seguro que quieres cerrar sesión?')) {
                    const { error } = await supabaseClient.auth.signOut();
                    if (error) showToast('Error: ' + error.message); else { showToast('Sesión cerrada.'); closeModal(); }
                }
            });

            document.getElementById('btn-manage-products').addEventListener('click', () => { 
                renderProductManagementList(); 
                renderCategoryManagementList();
                switchManagementTab('products');
                openModal('product-management-modal'); 
            });

            // Abrir modal de clientes
            const btnManageClients = document.getElementById('btn-manage-clients');
            if (btnManageClients) {
                btnManageClients.addEventListener('click', openClientsModal);
            }

            // Botón para agregar nuevo cliente
            const addClientBtn = document.getElementById('add-client-btn');
            if (addClientBtn) {
                addClientBtn.addEventListener('click', () => openClientForm());
            }

            // Envío del formulario de cliente
            const clientForm = document.getElementById('client-form');
            if (clientForm) {
                clientForm.addEventListener('submit', async (e) => {
                    e.preventDefault();
                    const id = document.getElementById('client-id').value;
                    const nombre = document.getElementById('client-name').value.trim();
                    const telefono = document.getElementById('client-phone').value.trim();
                    const email = document.getElementById('client-email').value.trim();
                    const direccion = document.getElementById('client-address').value.trim();
                    const limite = parseFloat(document.getElementById('client-limit').value) || 0;
                    const payload = { nombre, telefono, email, direccion, limite_credito: limite };
                    try {
                        if (id) {
                            const { error } = await supabaseClient.from('clientes').update(payload).eq('id', id);
                            if (error) { showToast('Error al actualizar cliente: ' + error.message); return; }
                            showToast('Cliente actualizado');
                        } else {
                            const { error } = await supabaseClient.from('clientes').insert([payload]);
                            if (error) { showToast('Error al crear cliente: ' + error.message); return; }
                            showToast('Cliente creado');
                        }
                        closeModal();
                        await openClientsModal();
                    } catch (err) {
                        console.error(err);
                        showToast('No se pudo guardar el cliente');
                    }
                });
            }

            // Gestionar ventas
            const btnManageSales = document.getElementById('btn-manage-sales');
            if (btnManageSales) {
                btnManageSales.addEventListener('click', () => {
                    // Cierra el carrito si está abierto para evitar que el fondo quede borroso
                    closeCartDrawer();
                    // Abre el panel de ventas tras un pequeño retraso
                    setTimeout(() => openSalesManagementModal(), 200);
                });
            }

            // Botón para abrir venta a crédito
            const creditSaleBtn = document.getElementById('btn-credit-sale');
            if (creditSaleBtn) {
                creditSaleBtn.addEventListener('click', openCreditSaleModal);
            }

            // Confirmar venta a crédito
            const confirmCreditBtn = document.getElementById('confirm-credit-sale-btn');
            if (confirmCreditBtn) {
                confirmCreditBtn.addEventListener('click', async () => {
                    const selectEl = document.getElementById('credit-client-select');
                    const clientId = selectEl ? selectEl.value : null;
                    if (!clientId) { showToast('Seleccione un cliente'); return; }
                    await recordCreditSale(clientId);
                    closeModal();
                });
            }

            document.getElementById('tab-btn-products').addEventListener('click', () => switchManagementTab('products'));
            document.getElementById('tab-btn-categories').addEventListener('click', () => switchManagementTab('categories'));

            document.getElementById('add-new-product-btn').addEventListener('click', () => openProductForm());
            document.getElementById('upload-json-btn').addEventListener('click', () => document.getElementById('json-upload-input').click());

            // Maneja la carga de un archivo JSON que contiene productos. Este flujo
            // reemplaza por completo los productos existentes: al seleccionar un
            // archivo, se lee su contenido, se valida que sea un arreglo de
            // objetos y se solicita confirmación al usuario. Si confirma, se
            // eliminan todos los registros de la tabla "productos" y se insertan
            // los nuevos elementos. Los IDs se generan si están ausentes para
            // evitar duplicados. Finalmente, la lista local y el filtro de
            // categorías se actualizan para reflejar el nuevo catálogo.
            const jsonUploadInput = document.getElementById('json-upload-input');
            if (jsonUploadInput) {
                jsonUploadInput.addEventListener('change', async (event) => {
                    const file = event.target.files[0];
                    if (!file) return;
                    try {
                        const text = await file.text();
                        const imported = JSON.parse(text);
                        if (!Array.isArray(imported)) {
                            showToast('El JSON debe contener un arreglo de productos');
                            event.target.value = '';
                            return;
                        }
                        // Solicita confirmación al usuario antes de eliminar e importar
                        if (!confirm('Esto reemplazará todos los productos existentes. ¿Desea continuar?')) {
                            event.target.value = '';
                            return;
                        }
                        // Elimina todos los productos actuales (sólo administradores tienen permiso)
                        const deleteRes = await supabaseClient.from('productos').delete().neq('id', '');
                        if (deleteRes.error) {
                            console.error(deleteRes.error);
                            showToast('Error eliminando productos existentes');
                            event.target.value = '';
                            return;
                        }
                        // Construye lista sanitizada de productos; genera ID si falta y asigna valores por defecto
                        const now = Date.now();
                        const sanitized = imported.map((prod, idx) => {
                            // Copiar sólo campos conocidos
                            const name = prod.name || '';
                            let id = prod.id;
                            if (!id || typeof id !== 'string') {
                                id = `prod_${slugify(name)}_${now}_${idx}`;
                            }
                            return {
                                id,
                                name,
                                description: prod.description || '',
                                category: prod.category || '',
                                price: typeof prod.price === 'number' ? prod.price : 0,
                                stock: typeof prod.stock === 'number' ? prod.stock : 0,
                                ideal_stock: typeof prod.ideal_stock === 'number' ? prod.ideal_stock : 0,
                                unit: prod.unit || 'Unidad',
                                is_service: !!prod.is_service,
                                sold_by_weight: !!prod.sold_by_weight,
                                sold_by_length: !!prod.sold_by_length,
                                allow_manual_price: !!prod.allow_manual_price,
                                image: prod.image || '',
                                created_at: prod.created_at || new Date().toISOString()
                            };
                        });
                        // Inserta productos con upsert para evitar conflictos
                        const insertRes = await supabaseClient.from('productos').upsert(sanitized);
                        if (insertRes.error) {
                            console.error(insertRes.error);
                            showToast('Error importando productos');
                            event.target.value = '';
                            return;
                        }
                        // Actualiza local
                        allProducts = sanitized;
                        localStorage.setItem('products', JSON.stringify(allProducts));
                        renderProducts();
                        renderCategoryFilters();
                        showToast('Productos importados correctamente');
                        // Limpia el input para permitir cargar nuevamente el mismo archivo si se desea
                        event.target.value = '';
                    } catch (err) {
                        console.error(err);
                        showToast('Error procesando el archivo JSON');
                        event.target.value = '';
                    }
                });
            }

            // Botón que abre el formulario para crear vendedores (sólo visible para administradores)
            const createSellerBtn = document.getElementById('btn-create-seller');
            if (createSellerBtn) {
                createSellerBtn.addEventListener('click', () => {
                    openModal('create-seller-modal');
                });
            }

            // Enviar el formulario de creación de vendedor. Envía una petición a la función serverless
            // /.netlify/functions/create-seller con email y contraseña. Muestra mensajes según el resultado.
            const createSellerForm = document.getElementById('create-seller-form');
            if (createSellerForm) {
                createSellerForm.addEventListener('submit', async e => {
                    e.preventDefault();
                    const email    = document.getElementById('seller-email').value;
                    const password = document.getElementById('seller-password').value;
                    if (!email || !password) {
                        showToast('Email y contraseña son obligatorios');
                        return;
                    }
                    try {
                        const response = await fetch('/.netlify/functions/create-seller', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ email, password })
                        });
                        // Intenta leer la respuesta como texto primero. Algunas respuestas de error de Netlify
                        // pueden no devolver JSON válido.
                        const text = await response.text();
                        let result;
                        try {
                            result = JSON.parse(text);
                        } catch (parseErr) {
                            result = { message: text };
                        }
                        if (response.ok) {
                            showToast(result.message || 'Vendedor creado correctamente');
                            closeModal();
                        } else {
                            showToast(result.message || 'Error al crear vendedor');
                        }
                    } catch (err) {
                        showToast(err.message || 'Error de red');
                    }
                });
            }

            // Vincula el buscador de gestión de productos para filtrar a medida que se escribe
            const productManageSearch = document.getElementById('product-manage-search');
            if (productManageSearch) {
                productManageSearch.addEventListener('input', () => {
                    renderProductManagementList();
                });
            }

            // ----------------------------------------------------------------------
            // Gestión de vendedores
            // Lista global de vendedores. Se cargará cuando se abra el modal de gestión.
            let sellerList = [];
            async function loadSellerList() {
                try {
                    const response = await fetch('/.netlify/functions/manage-seller');
                    const text = await response.text();
                    let sellers;
                    try { sellers = JSON.parse(text); } catch { sellers = []; }
                    if (response.ok) {
                        sellerList = Array.isArray(sellers) ? sellers : [];
                        renderSellerList();
                    } else {
                        showToast((sellers && sellers.message) || 'Error al obtener vendedores');
                    }
                } catch (err) {
                    showToast(err.message || 'Error al obtener vendedores');
                }
            }
            function renderSellerList() {
                const container = document.getElementById('seller-list-container');
                if (!container) return;
                container.innerHTML = '';
                const searchInput = document.getElementById('seller-search');
                const query = searchInput && searchInput.value ? searchInput.value.trim().toLowerCase() : '';
                const filtered = sellerList.filter(s => s.email && s.email.toLowerCase().includes(query));
                if (filtered.length === 0) {
                    container.innerHTML = '<p class="text-center text-text-secondary p-4">No hay vendedores.</p>';
                    return;
                }
                filtered.forEach(seller => {
                    const row = document.createElement('div');
                    row.className = 'flex justify-between items-center border-b border-border-color p-2 last:border-b-0';
                    row.innerHTML = `
                        <div><p class="font-medium">${seller.email}</p></div>
                        <div class="flex gap-2">
                            <button class="edit-seller-btn btn btn-secondary text-xs py-1 px-2" data-id="${seller.id}" data-email="${seller.email}">Editar</button>
                            <button class="delete-seller-btn btn btn-danger text-xs py-1 px-2" data-id="${seller.id}" data-email="${seller.email}">Eliminar</button>
                        </div>`;
                    container.appendChild(row);
                });
                container.querySelectorAll('.edit-seller-btn').forEach(btn => {
                    btn.addEventListener('click', handleEditSeller);
                });
                container.querySelectorAll('.delete-seller-btn').forEach(btn => {
                    btn.addEventListener('click', handleDeleteSeller);
                });
            }
            async function handleEditSeller(e) {
                const id = e.currentTarget.dataset.id;
                const email = e.currentTarget.dataset.email;
                const newPass = prompt(`Cambiar contraseña para ${email}:\nIntroduce la nueva contraseña`);
                if (!newPass) return;
                try {
                    const response = await fetch('/.netlify/functions/manage-seller', {
                        method: 'PUT',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ id, password: newPass })
                    });
                    const text = await response.text();
                    let data;
                    try { data = JSON.parse(text); } catch { data = { message: text }; }
                    if (response.ok) {
                        showToast(data.message || 'Contraseña actualizada');
                    } else {
                        showToast(data.message || 'Error actualizando contraseña');
                    }
                } catch (err) {
                    showToast(err.message || 'Error de red');
                }
            }
            async function handleDeleteSeller(e) {
                const id = e.currentTarget.dataset.id;
                const email = e.currentTarget.dataset.email;
                if (!await showConfirmation(`¿Seguro que quieres eliminar al vendedor ${email}? Esta acción es irreversible.`)) return;
                try {
                    const response = await fetch(`/.netlify/functions/manage-seller?id=${encodeURIComponent(id)}`, { method: 'DELETE' });
                    const text = await response.text();
                    let data;
                    try { data = JSON.parse(text); } catch { data = { message: text }; }
                    if (response.ok) {
                        showToast(data.message || 'Vendedor eliminado');
                        // Remove from local list and re-render
                        sellerList = sellerList.filter(s => s.id !== id);
                        renderSellerList();
                    } else {
                        showToast(data.message || 'Error eliminando vendedor');
                    }
                } catch (err) {
                    showToast(err.message || 'Error de red');
                }
            }
            // Evento para abrir el modal de gestión de vendedores y cargar la lista
            const manageSellersBtn = document.getElementById('btn-manage-sellers');
            if (manageSellersBtn) {
                manageSellersBtn.addEventListener('click', () => {
                    openModal('seller-management-modal');
                    loadSellerList();
                });
            }
            // Filtra vendedores a medida que se escribe
            const sellerSearchInput = document.getElementById('seller-search');
            if (sellerSearchInput) {
                sellerSearchInput.addEventListener('input', () => {
                    renderSellerList();
                });
            }
            
            function exportProductsAsJson() {
                if (!allProducts || allProducts.length === 0) {
                    showToast('No hay productos para exportar.');
                    return;
                }
                const dataStr = JSON.stringify(allProducts, null, 2);
                const dataBlob = new Blob([dataStr], { type: 'application/json' });
                const url = URL.createObjectURL(dataBlob);
                const link = document.createElement('a');
                link.href = url;
                const timestamp = new Date().toISOString().slice(0, 10);
                link.download = `productos-${timestamp}.json`;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(url);
                showToast('Productos exportados a JSON.');
            }
            document.getElementById('export-json-btn').addEventListener('click', exportProductsAsJson);
            
            document.getElementById('product-form').addEventListener('submit', async e => {
                e.preventDefault(); let id = document.getElementById('product-id').value;
                if (!id) id = 'prod_' + slugify(document.getElementById('product-name').value) + '_' + Date.now();
                const productData = { 
                    id, 
                    name: document.getElementById('product-name').value, 
                    category: document.getElementById('product-category').value, 
                    price: parseFloat(document.getElementById('product-price').value), 
                    stock: parseFloat(document.getElementById('product-stock').value), 
                    ideal_stock: parseFloat(document.getElementById('product-ideal_stock').value) || 0,
                    unit: document.getElementById('product-unit').value, 
                    image: document.getElementById('product-image').value, 
                    description: document.getElementById('product-description').value, 
                    is_service: document.getElementById('product-is_service').checked, 
                    sold_by_weight: document.getElementById('product-sold_by_weight').checked, 
                    sold_by_length: document.getElementById('product-sold_by_length').checked, 
                    allow_manual_price: document.getElementById('product-allow_manual_price').checked 
                };
                const { error } = await supabaseClient.from('productos').upsert(productData, { onConflict: 'id' });
                if(error) { 
                    showToast('Error: ' + error.message); 
                } else { 
                    // The real-time listener will catch the update, but we update locally for instant UI feedback
                    const index = allProducts.findIndex(p => p.id === productData.id);
                    if (index > -1) {
                        allProducts[index] = productData;
                    } else {
                        allProducts.push(productData);
                    }
                    localStorage.setItem('products', JSON.stringify(allProducts));
                    filterProducts();
                    renderCategoryFilters();
                    showToast('Producto guardado.'); 
                    closeModal(); 
                }
            });
            document.getElementById('delete-product-btn').addEventListener('click', async () => {
                const id = document.getElementById('product-id').value;
                if (id && await showConfirmation('¿Seguro que quieres eliminar este producto de forma permanente?')) {
                    const { error } = await supabaseClient.from('productos').delete().eq('id', id);
                    if(error) {
                         showToast('Error: ' + error.message);
                    }
                    
                    // The real-time listener will catch the update, but we update locally for instant UI feedback
                    const index = allProducts.findIndex(p => p.id === id);
                    if (index > -1) allProducts.splice(index, 1);
                    localStorage.setItem('products', JSON.stringify(allProducts));
                    
                    showToast('Producto eliminado.');
                    closeModal();
                    filterProducts();
                    renderCategoryFilters();
                }
            });

            document.getElementById('quantity-modal-confirm').addEventListener('click', () => {
                const p = allProducts.find(p => p.id === document.getElementById('quantity-product-id').value); if(!p) return;
                const quantity = parseFloat(document.getElementById('quantity-input').value); if (isNaN(quantity) || quantity <= 0) { showToast('Cantidad inválida'); return; }
                let price = p.price;
                if (p.allow_manual_price) { const newPrice = parseFloat(document.getElementById('manual-price-input').value); if(isNaN(newPrice) || newPrice < 0){ showToast('Precio inválido'); return; } price = newPrice; }
                addToCart(p, quantity, price); closeModal();
            });

            document.getElementById('btn-finalize').addEventListener('click', () => { if (!session) { showToast('Debes iniciar sesión'); return; } if (window.cart.length === 0) { showToast('El carrito está vacío'); return; } openPaymentModal(); closeCartDrawer(); });
            document.getElementById('confirm-payment-btn').addEventListener('click', async () => {
                const paymentMethods = {};
                document.querySelectorAll('.payment-input').forEach(input => { const amount = parseFloat(input.value) || 0; if (amount > 0) paymentMethods[input.dataset.method] = amount; });
                if (await safeRecordSale(paymentMethods)) { clearCartAndNotify(); closeModal(); }
            });
            document.getElementById('btn-wa').addEventListener('click', async () => {
                if(window.cart.length === 0) { showToast('El carrito está vacío.'); return; }
                const choice = await waChoice();
                if(!choice) return;

                if(choice === 'venta'){
                    if(!session){ showToast('Debes iniciar sesión para registrar una venta.'); return; }
                    openPaymentModal(); 
                } else if(choice === 'presupuesto'){
                    const ticket = buildTicket(window.cart, window.exchangeRate);
                    const url = 'https://wa.me/?text=' + encodeURIComponent(ticket);
                    window.open(url, '_blank');
                }
                closeCartDrawer();
            });
                const summaryButtonEl = document.getElementById('btn-summary');
                if (summaryButtonEl) {
                    summaryButtonEl.addEventListener('click', () => {
                        // Primero cierra el carrito para evitar interferencias con el modal
                        closeCartDrawer();
                        // Abre el modal de opciones tras un breve retraso para asegurar que el drawer se haya ocultado
                        setTimeout(() => openSummaryOptionsModal(), 200);
                    });
                }
            // El botón de análisis de ventas ha sido eliminado porque no hay API de IA disponible.
            // Igualmente, se ha eliminado la generación de descripciones automática.

            initializeApp();
        });
    